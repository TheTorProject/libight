// Part of Measurement Kit <https://measurement-kit.github.io/>.
// Measurement Kit is free software under the BSD license. See AUTHORS
// and LICENSE for more information on the copying conditions.
#ifndef MEASUREMENT_KIT_NETTEST_HPP
#define MEASUREMENT_KIT_NETTEST_HPP

/*-
 *  __      __  _____ __________  _______  .___ _______    ________
 * /  \    /  \/  _  \\______   \ \      \ |   |\      \  /  _____/
 * \   \/\/   /  /_\  \|       _/ /   |   \|   |/   |   \/   \  ___
 *  \        /    |    \    |   \/    |    \   /    |    \    \_\  \
 *   \__/\  /\____|__  /____|_  /\____|__  /___\____|__  /\______  /
 *        \/         \/       \/         \/            \/        \/
 *
 * Autogenerated by `./script/autoapi/autoapi`. DO NOT EDIT!!!
 */

/// \file include/measurement_kit/nettest.hpp
///
/// \brief C++11 API for running nettests.
///
/// This API is a C++11 adaptation of MK's FFI API. You should probably read
/// about such API first. \see https://github.com/measurement-kit/measurement-kit/blob/master/include/measurement_kit/README.md.
///
/// Usage is as follows:
///
/// ### 1. Instantiate settings
///
/// Create an instance of the settings of the nettest that you want to run
/// and set all the settings that you care about. You can pass around a
/// pointer or reference to the base class if you have common code written
/// to setup common options among different tests.
///
/// ```
/// extern void set_more_common_settings(mk::nettest::common::Settings *);
/// mk::nettest::WhatsappSettings settings;
/// settings.all_endpoints = true;
/// settings.log_level = mk::nettest::log_level_info;
/// set_more_common_settings(&settings);
/// ```
///
/// ### 2. Optional: subclass your nettest
///
/// Create a subclass of the nettest you want to run, where you override
/// all the events that you would like to handle.
///
/// ```
/// class MyWhatsapp : public mk::nettest::WhatsappNettest {
///  public:
///   using mk::nettest::WhatsappNettest::WhatsappNettest;
///
///   void on_log(mk::nettest::LogEvent event) override {
///     // Your event handling code here. Remember that this is called
///     // in the context of the FFI API's background thread.
///     //
///     // In this example we emit log messages on the standard error.
///     std::clog << event.log_level << ": " << event.message.
///   }
///
///  private:
///   // Your implementation variables here
/// }
/// ```
///
/// ### 3. Instantiate the nettest
///
/// Create an instance of the nettest (or of a derived class) passing to
/// the constructor the settings you created in step 1.
///
/// ```
/// MyWhatsapp nettest{std::move(settings)};
/// ```
///
/// ### 4. Call run()
///
/// Start the nettest by calling run(). This method will return true if the
/// nettest was executed correctly and false on errors. In such case, you
/// will find more information by looking at the emitted "log" events.
///
/// ```
/// if (!nettest.run()) {
///   // TODO: your code for handling this failure here.
///   return;
/// }
/// ```
///
/// ### 5. Final remarks
///
/// To interrupt a nettest, use Nettest::interrupt(). When you need to share
/// a Nettest instance between different threads for the purpose of interrupting
/// it, use `new` or, event better, `std::make_shared`.
///
/// \see https://github.com/measurement-kit/measurement-kit/tree/master/example/nettest for usage examples.

#include <assert.h>
#include <stdint.h>

#include <deque>
#include <iostream>
#include <map>
#include <memory>
#include <mutex>
#include <sstream>
#include <string>
#include <thread>
#include <utility>
#include <vector>

#include <measurement_kit/common/nlohmann/json.hpp>
#include <measurement_kit/ffi.h>

/// Measurement Kit namespace.
namespace mk {

/// Namespace containing the nettest API.
namespace nettest {

{% for log_level in log_levels %}/// String representation of the "{{ log_level }}" log level.
constexpr const char *log_level_{{ log_level }} = "{{ log_level.upper() }}";{{ "\n\n" if not loop.last }}{% endfor %}

{% for event in events %}/// C++ representation of the "{{ event.key }}" event.
class {{ event.cxx_class_name }}Event {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "{{ event.key }}";
    {% if event.attributes %}{% for attribute in event.attributes %}{{ "\n    " }}/// The "{{ attribute.key }}" attribute of this event.
    {{ attribute.cxx_type }} {{ attribute.key }} = {{ attribute.value }};{{ "\n    " if not loop.last }}{% endfor %}{% else %}/* No attributes */{% endif %}
};{{ "\n\n" if not loop.last }}{% endfor %}

#if !defined SWIG && !defined DOXYGEN
namespace detail {

// Deleter for mk_task_t.
class TaskDeleter {
  public:
    void operator()(mk_task_t *task) noexcept;
};

// Syntactic sugar of a unique mk_task_t pointer.
using UniqueTask = std::unique_ptr<mk_task_t, TaskDeleter>;

// Deleter for mk_event_t.
class EventDeleter {
  public:
    void operator()(mk_event_t *event) noexcept;
};

// Syntactic sugar for a unique mk_event_t pointer.
using UniqueEvent = std::unique_ptr<mk_event_t, EventDeleter>;

} // namespace detail
#endif // !SWIG && !DOXYGEN

/// Settings common to all nettests.
class Settings {
  public:
    {% for setting in settings if not setting.internal %}/// The "{{ setting.key  }}" setting.
    {{ setting.cxx_type }} {{ setting.key }} = {{ setting.value }};{{ "\n\n    " if not loop.last }}{% endfor %}

    {% for option in options %}/// The "{{ option.key }}" setting.
    {{ option.cxx_type }} {{ option.key | replace("/", "_") }} = {{ option.value }};{{ "\n\n    " if not loop.last }}{% endfor %}

#ifdef SWIG
  private:
#endif
    // Serialize common settings into a JSON document.
    bool serialize_into(nlohmann::json *) noexcept;
};

/// Common generic code.
namespace common {

/// Base class for all nettests.
class Nettest {
  public:
    // Implementation note: we cannot have `noexcept` in virtual methods to be
    // overriden using SWIG because the current stable version of SWIG does not
    // correctly handle `noexcept` (but this seems to be fixed in master).

    // C++ object model
    // ````````````````

    /// Empty default constructor.
    Nettest() noexcept;

    /// Explicitly deleted copy constructor.
    Nettest(const Nettest &) noexcept = delete;

    /// Explicitly deleted copy assignment.
    Nettest &operator=(const Nettest &) noexcept = delete;

    /// Explicitly deleted move constructor.
    Nettest(Nettest &&) noexcept = delete;

    /// Explicitly deleted move assignment.
    Nettest &operator=(Nettest &&) noexcept = delete;

    /// Wait for nettest to terminate and destroy resources.
    virtual ~Nettest() noexcept;

    // Lifecycle
    // `````````

    /// Runs the nettest.
    virtual bool run() noexcept { return false; }

    /// Interrupts a running nettest.
    void interrupt() noexcept;

    // Event handlers
    // ``````````````

    {% for event in events if event.tag == "common" %}/// Handles the "{{ event.key }}" event.
    virtual void on_{{ event.key | replace(".", "_") }}({{ event.cxx_class_name }}Event);{{ "\n\n    " if not loop.last }}{% endfor %}

  protected:
    // Start a nettest given JSON settings
    bool run_with_json_settings(nlohmann::json doc) noexcept;

    // Dispatch the JSON event to the proper handler
    virtual bool dispatch_event(nlohmann::json doc) noexcept;

  private:
    std::mutex mutex_;
    detail::UniqueTask task_;
};

/// Base class for nettests measuring performance.
class PerformanceNettest : public Nettest {
  public:
    /// Wait for nettest to terminate and destroy resources.
    ~PerformanceNettest() noexcept override {}

    {% for event in events if event.tag == "performance" %}/// Handles the "{{ event.key }}" event.
    virtual void on_{{ event.key | replace(".", "_") }}({{ event.cxx_class_name }}Event);{{ "\n\n    " if not loop.last }}{% endfor %}

  protected:
    // Dispatch the JSON event to the proper handler
    bool dispatch_event(nlohmann::json doc) noexcept override;
};

/// Base class for nettest measuring websites blocking.
class WebsitesNettest : public Nettest {
  public:
    /// Wait for nettest to terminate and destroy resources.
    ~WebsitesNettest() noexcept override {}

    {% for event in events if event.tag == "websites" %}/// Handles the "{{ event.key }}" event.
    virtual void on_{{ event.key | replace(".", "_") }}({{ event.cxx_class_name }}Event);{{ "\n\n    " if not loop.last }}{% endfor %}

  protected:
    // Dispatch the JSON event to the proper handler
    bool dispatch_event(nlohmann::json doc) noexcept override;
};

} // namespace common

{% for nettest in nettests %}#ifndef MK_NETTEST_NO_{{ nettest.snake_case_name.upper() }}

/// Settings for {{ nettest.name }}
class {{ nettest.name }}Settings : public Settings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "{{ nettest.name }}";
    {% if nettest.attributes %}{% for attribute in nettest.attributes %}{{ "\n    "}}/// The "{{ attribute.key }}" setting of this nettest.
    {{ attribute.cxx_type}} {{ attribute.key }} = {{ attribute.value }};{{ "\n    " if not loop.last }}{% endfor %}{% else %}/* No nettest-specific settings */{% endif %}

#ifdef SWIG
  private:
#endif
    // Serialize {{ nettest.name }} settings into a JSON document.
    bool serialize_into(nlohmann::json *) noexcept;
};

/// The {{ nettest.name }} nettest.
class {{ nettest.name }}Nettest : public common::{{ nettest.base_nettest_class }}Nettest {
  public:
    /// Constructor with explicit settings.
    explicit {{ nettest.name }}Nettest({{nettest.name }}Settings) noexcept;

    /// Wait for nettest to terminate and destroy resources.
    ~{{ nettest.name }}Nettest() noexcept override;

    /// Runs the nettest.
    bool run() noexcept override;

  private:
    {{ nettest.name }}Settings settings_;
};

#endif // !MK_NETTEST_NO_{{ nettest.snake_case_name.upper() }}{{ "\n\n" if not loop.last }}{% endfor %}

/*-
 * __________        .__               __
 * \______   \_______|__|__  _______ _/  |_  ____
 *  |     ___/\_  __ \  \  \/ /\__  \\   __\/ __ \
 *  |    |     |  | \/  |\   /  / __ \|  | \  ___/
 *  |____|     |__|  |__| \_/  (____  /__|  \___  >
 *                                  \/          \/
 *
 * Definitions ends here. What follows is the inline implementation of this
 * API, which you can exclude by setting MK_NETTEST_NO_INLINE_IMPL.
 *
 * This is handy if you want to include this code in many translation
 * units to include the implementation into a single object.
 */
#if !defined MK_NETTEST_NO_INLINE_IMPL && !defined SWIG

namespace detail {

void TaskDeleter::operator()(mk_task_t *task) noexcept {
    mk_task_destroy(task);
}

void EventDeleter::operator()(mk_event_t *event) noexcept {
    mk_event_destroy(event);
}

} // namespace detail

// # Settings

bool Settings::serialize_into(nlohmann::json *doc) noexcept {
    if (doc == nullptr) {
        return false;
    }
    {% for setting in settings if not setting.internal %}(*doc)["{{ setting.key }}"] = {{ setting.cxx_cast_to_json }}{{ setting.key }};{{ "\n    " if not loop.last }}{% endfor %}
    {
        auto &o = (*doc)["options"];
        {% for option in options %}o["{{ option.key }}"] = {{ option.cxx_cast_to_json }}{{ option.key | replace("/", "_") }};{{ "\n        " if not loop.last }}{% endfor %}
    }
    return true;
}

namespace common {

// # Nettest

Nettest::Nettest() noexcept {}

Nettest::~Nettest() noexcept {}

void Nettest::interrupt() noexcept {
    std::unique_lock<std::mutex> _{mutex_};
    mk_task_interrupt(task_.get());
}

{% for event in events if event.tag == "common" %}void Nettest::on_{{ event.key | replace(".", "_") }}({{ event.cxx_class_name }}Event event) {
#ifdef MK_NETTEST_VERBOSE_DEFAULT_HANDLERS
    std::clog << "{{ event.key }}";
    {% if event.attributes %}std::clog << ":";
    {% for attribute in event.attributes %}std::clog << " {{ attribute.key }}='" << event.{{ attribute.key }} << "'";{{ "\n    " if not loop.last }}{% endfor %}{% else %}(void)event; /* No event attributes */{% endif %}
    std::clog << std::endl;
#else
    (void)event;
#endif
}{{ "\n\n" if not loop.last }}{% endfor %}

bool Nettest::run_with_json_settings(nlohmann::json settingsdoc) noexcept {
    {
        std::unique_lock<std::mutex> _{mutex_};
        if (task_ != nullptr) {
            // TODO(bassosimone): route this error.
            return false;
        }
        std::string str;
        try {
            str = settingsdoc.dump();
        } catch (const std::exception &) {
            // TODO(bassosimone): route this error.
            return false;
        }
#ifdef MK_NETTEST_TRACE
        std::clog << "NETTEST: settings: " << str << std::endl;
#endif
        task_.reset(mk_task_start(str.c_str()));
        if (task_ == nullptr) {
            // TODO(bassosimone): route this error.
            return false;
        }
    }
    for (;;) {
        nlohmann::json eventdoc;
        {
            detail::UniqueEvent eventptr;
            {
                std::unique_lock<std::mutex> _{mutex_};
                if (mk_task_is_done(task_.get())) {
                    break;
                }
                eventptr.reset(mk_task_wait_for_next_event(task_.get()));
            }
            if (eventptr == nullptr) {
                // TODO(bassosimone): route this error.
                interrupt();
                return false;
            }
            auto str = mk_event_serialize(eventptr.get());
            if (!str) {
                // TODO(bassosimone): route this error.
                interrupt();
                return false;
            }
#ifdef MK_NETTEST_TRACE
            std::clog << "NETTEST: event: " << str << std::endl;
#endif
            try {
                eventdoc = nlohmann::json::parse(str);
            } catch (const std::exception &) {
                // TODO(bassosimone): route this error.
                interrupt();
                return false;
            }
        }
        if (eventdoc.count("key") != 1 || !eventdoc.at("key").is_string() ||
                eventdoc.count("value") != 1 ||
                !eventdoc.at("value").is_object()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return false;
        }
        {% for event in events %}if (eventdoc.at("key") == {{ event.cxx_class_name }}Event::key) {
            {% if event.attributes %}{% for attribute in event.attributes %}if (eventdoc.at("value").count("{{ attribute.key }}") != 1 ||
                    !eventdoc.at("value").at("{{ attribute.key }}").is_{{ attribute.json_type }}()) {
                // TODO(bassosimone): route this error.
                interrupt();
                return false;
            }{{ "\n            " if not loop.last }}{% endfor %}{% else %}/* No event attributes */{% endif %}
            if (!dispatch_event(std::move(eventdoc))) {
                // TODO(bassosimone): route this error.
                interrupt();
                return false;
            }
            continue;
        }{{ "\n        " if not loop.last }}{% endfor %}
#ifdef MK_NETTEST_TRACE
        std::clog << "NETTEST: unhandled event: " << str << std::endl;
#endif
        // TODO(bassosimone): route this error.
        interrupt();
        return false;
    }
    return true;
}

bool Nettest::dispatch_event(nlohmann::json doc) noexcept {
    {% for event in events if event.tag == "common" %}if (doc.at("key") == {{ event.cxx_class_name }}Event::key) {
        {{ event.cxx_class_name}}Event event;
        {% if event.attributes %}{% for attribute in event.attributes %}event.{{ attribute.key }} = {{ attribute.cxx_cast_from_json }}doc.at("value").at("{{ attribute.key }}");{{ "\n        " if not loop.last }}{% endfor %}{% else %}/* No attributes */{% endif %}
        on_{{ event.key | replace(".", "_") }}(std::move(event));
        return true;
    }{{ "\n    " if not loop.last }}{% endfor %}
    return false;
}

// # PerformanceNettest

{% for event in events if event.tag == "performance" %}void PerformanceNettest::on_{{ event.key | replace(".", "_") }}({{ event.cxx_class_name }}Event event) {
#ifdef MK_NETTEST_VERBOSE_DEFAULT_HANDLERS
    std::clog << "{{ event.key }}";
    {% if event.attributes %}std::clog << ":";
    {% for attribute in event.attributes %}std::clog << " {{ attribute.key }}='" << event.{{ attribute.key }} << "'";{{ "\n    " if not loop.last }}{% endfor %}{% else %}(void)event; /* No event attributes */{% endif %}
    std::clog << std::endl;
#else
    (void)event;
#endif
}{{ "\n\n" if not loop.last }}{% endfor %}

bool PerformanceNettest::dispatch_event(nlohmann::json doc) noexcept {
    {% for event in events if event.tag == "performance" %}if (doc.at("key") == {{ event.cxx_class_name }}Event::key) {
        {{ event.cxx_class_name}}Event event;
        {% if event.attributes %}{% for attribute in event.attributes %}event.{{ attribute.key }} = {{ attribute.cxx_cast_from_json }}doc.at("value").at("{{ attribute.key }}");{{ "\n        " if not loop.last }}{% endfor %}{% else %}/* No attributes */{% endif %}
        on_{{ event.key | replace(".", "_") }}(std::move(event));
        return true;
    }{{ "\n    " if not loop.last }}{% endfor %}
    return Nettest::dispatch_event(std::move(doc));
}

// # WebsitesNettest

{% for event in events if event.tag == "websites" %}void WebsitesNettest::on_{{ event.key | replace(".", "_") }}({{ event.cxx_class_name }}Event event) {
#ifdef MK_NETTEST_VERBOSE_DEFAULT_HANDLERS
    std::clog << "{{ event.key }}";
    {% if event.attributes %}std::clog << ":";
    {% for attribute in event.attributes %}std::clog << " {{ attribute.key }}='" << event.{{ attribute.key }} << "'";{{ "\n    " if not loop.last }}{% endfor %}{% else %}(void)event; /* No event attributes */{% endif %}
    std::clog << std::endl;
#else
    (void)event;
#endif
}{{ "\n\n" if not loop.last }}{% endfor %}

bool WebsitesNettest::dispatch_event(nlohmann::json doc) noexcept {
    {% for event in events if event.tag == "websites" %}if (doc.at("key") == {{ event.cxx_class_name }}Event::key) {
        {{ event.cxx_class_name}}Event event;
        {% if event.attributes %}{% for attribute in event.attributes %}event.{{ attribute.key }} = {{ attribute.cxx_cast_from_json }}doc.at("value").at("{{ attribute.key }}");{{ "\n        " if not loop.last }}{% endfor %}{% else %}/* No attributes */{% endif %}
        on_{{ event.key | replace(".", "_") }}(std::move(event));
        return true;
    }{{ "\n    " if not loop.last }}{% endfor %}
    return Nettest::dispatch_event(std::move(doc));
}

} // namespace common

{% for nettest in nettests %}// # {{ nettest.name }}

#ifndef MK_NETTEST_NO_{{ nettest.snake_case_name.upper() }}

bool {{ nettest.name }}Settings::serialize_into(nlohmann::json *doc) noexcept {
    (*doc)["name"] = "{{ nettest.name }}";
    {% if nettest.attributes %}{% for attribute in nettest.attributes %}(*doc)["options"]["{{ attribute.key}}"] = {{ attribute.cxx_cast_to_json }}{{ attribute.key }};{{ "\n    " if not loop.last }}{% endfor %}{% else %}/* No nettest specific settings */{% endif %}
    return Settings::serialize_into(doc);
}

{{ nettest.name }}Nettest::{{ nettest.name }}Nettest({{nettest.name }}Settings settings) noexcept {
    std::swap(settings_, settings);
}

{{ nettest.name }}Nettest::~{{ nettest.name }}Nettest() noexcept {}

bool {{ nettest.name }}Nettest::run() noexcept {
    nlohmann::json doc;
    if (!settings_.serialize_into(&doc)) {
        // TODO(bassosimone): route this error
        return false;
    }
    return run_with_json_settings(std::move(doc));
}

#endif // !MK_NETTEST_NO_{{ nettest.snake_case_name.upper() }}{{ "\n\n" if not loop.last }}{% endfor %}

#endif // !MK_NETTEST_NO_INLINE_IMPL && !SWIG
} // namespace nettest
} // namespace mk
#endif // MEASUREMENT_KIT_NETTEST_HPP

