// Part of Measurement Kit <https://measurement-kit.github.io/>.
// Measurement Kit is free software under the BSD license. See AUTHORS
// and LICENSE for more information on the copying conditions.
#ifndef MEASUREMENT_KIT_NETTEST_HPP
#define MEASUREMENT_KIT_NETTEST_HPP

/*-
 *  __      __  _____ __________  _______  .___ _______    ________
 * /  \    /  \/  _  \\______   \ \      \ |   |\      \  /  _____/
 * \   \/\/   /  /_\  \|       _/ /   |   \|   |/   |   \/   \  ___
 *  \        /    |    \    |   \/    |    \   /    |    \    \_\  \
 *   \__/\  /\____|__  /____|_  /\____|__  /___\____|__  /\______  /
 *        \/         \/       \/         \/            \/        \/
 *
 * Autogenerated by `./script/autoapi/autoapi`. DO NOT EDIT!!!
 */

/// \file include/measurement_kit/nettest.hpp
///
/// \brief C++11 API for running nettests.
///
/// This API is a C++11 adaptation of MK's FFI API. You should probably read
/// about such API first. \see https://github.com/measurement-kit/measurement-kit/blob/master/include/measurement_kit/README.md.
///
/// Usage is as follows:
///
/// ### 1. Instantiate settings
///
/// Create an instance of the settings of the nettest that you want to run
/// and set all the settings that you care about. You can pass around a
/// pointer or reference to the base class if you have common code written
/// to setup common options among different tests.
///
/// ```
/// extern void set_more_common_settings(mk::nettest::settings::CommonSettings *);
/// mk::nettest::settings::WhatsappSettings settings;
/// settings.all_endpoints = true;
/// settings.log_level = settings.log_level_info;
/// set_more_common_settings(&settings);
/// ```
///
/// ### 2. Instatiate Nettest
///
/// Create an instance of the Nettest class. This class is non copyable
/// and non movable. If you want unique or shared ownership, you can
/// instantiate it either using `std::make_unique` or `std::make_shared`.
///
/// ```
/// mk::nettest::Nettest nettest;
/// ```
///
/// ### 3. Subclass Router
///
/// Create a subclass of Router suitable for routing the events that
/// the nettest will emit to overriden methods written by you. The default
/// behavior of the router is to ignore all events.
///
/// ```
/// class MyRouter : public mk::nettest::routers::Router {
///  public:
///   using mk::nettest::routers::Router::Router;
///
///   void on_log(const mk::nettest::event::LogEvent &event) override {
///     // Your event handling code here. Remember that this is called
///     // in the context of the FFI API's background thread.
///     //
///     // In this example we emit log messages on the standard error.
///     std::clog << event.log_level << ": " << event.message.
///   }
///
///  private:
///   // Your implementation variables here
/// }
/// ```
///
/// ### 4. Instantiate your router specialization
///
/// Create an instance of your router that will be used by this nettest. You
/// will later pass a pointer to this instance to methods emitting events.
///
/// ```
/// MyRouter my_router;
/// ```
///
/// ### 5. Start the Nettest
///
/// Start the nettest using the specific start method for the nettest
/// that you want to run. After this nettest specific method is called,
/// all the other methods are nettest-agnostic, so you can have a lot
/// of common nettest-processing code. Make sure you check the value
/// returned by the nettest-specific start method. In case of error log
/// messages will be emitted through the router.
///
/// ```
/// if (!nettest.start_whatsapp(&my_router)) {
///   // TODO: your code for handling this failure here.
///   return;
/// }
/// ```
///
/// ### 6. Dispatch nettest events
///
/// Dispatch nettest events. This is nettest-agnostic code. Calling the
/// Nettest::route_next_event() method will cause any pending events
/// to be extracted from the events queue and emitted through the router.
///
/// ```
/// while (!nettest.is_done()) {
///   nettest.route_next_event(&my_router);
/// }
/// ```
///
/// ### 7. Final remarks
///
/// If the nettest goes out of scope, it will not be interrupted, rather it
/// will run until completion without routing events. To interrupt a nettest,
/// use Nettest::interrupt(). When you need to share a Nettest instance
/// between different threads for the purpose of interrupting a test, your
/// best option is to use `new` or `std::make_shared`.
///
/// \see https://github.com/measurement-kit/measurement-kit/tree/master/example/nettest for usage examples.

#include <assert.h>
#include <stdint.h>

#include <deque>
#include <iostream>
#include <map>
#include <memory>
#include <mutex>
#include <sstream>
#include <string>
#include <thread>
#include <utility>
#include <vector>

#include <measurement_kit/common/nlohmann/json.hpp>
#include <measurement_kit/ffi.h>

/// Measurement Kit namespace.
namespace mk {

/// Namespace containing the nettest API.
namespace nettest {

/// Contains events definitions.
namespace events {

{% for event in events %}/// C++ representation of the "{{ event.key }}" event.
class {{ event.cxx_class_name }}Event {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "{{ event.key }}";
    {% if event.attributes %}{% for attribute in event.attributes %}{{ "\n    " }}/// The "{{ attribute.key }}" attribute of this event.
    {{ attribute.cxx_type }} {{ attribute.key }} = {{ attribute.value }};{{ "\n    " if not loop.last }}{% endfor %}{% else %}/* No attributes */{% endif %}
};{{ "\n\n" if not loop.last }}{% endfor %}

} // namespace events

/// Contains settings classes.
namespace settings {

/// Settings common to all nettests.
class CommonSettings {
  public:
    {% for log_level in log_levels %}/// String representation of the "{{ log_level }}" log level.
    static constexpr const char *log_level_{{ log_level }} = "{{ log_level.upper() }}";{{ "\n\n    " if not loop.last }}{% endfor %}

    {% for setting in settings if not setting.internal %}/// The "{{ setting.key  }}" setting.
    {{ setting.cxx_type }} {{ setting.key }} = {{ setting.value }};{{ "\n\n    " if not loop.last }}{% endfor %}

    {% for option in options %}/// The "{{ option.key }}" setting.
    {{ option.cxx_type }} {{ option.key | replace("/", "_") }} = {{ option.value }};{{ "\n\n    " if not loop.last }}{% endfor %}
};

{% for nettest in nettests %}/// Settings of the "{{ nettest.name }}" nettest.
class {{ nettest.name }}Settings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "{{ nettest.name }}";
    {% if nettest.attributes %}{% for attribute in nettest.attributes %}{{ "\n    "}}/// The "{{ attribute.key }}" setting of this nettest.
    {{ attribute.cxx_type}} {{ attribute.key }} = {{ attribute.value }};{{ "\n    " if not loop.last }}{% endfor %}{% else %}/* No nettest-specific settings */{% endif %}
};{{ "\n\n" if not loop.last }}{% endfor %}

} // namespace settings

// Contains the routers
namespace routers {

/// Routes nettest events to virtual methods.
class Router {
  public:
    // Implementation note: virtual methods cannot be `noexcept` because the
    // task stable version of SWIG does not handle that correctly.

    {% for event in events %}/// Handles the "{{ event.key }}" event.
    virtual void on_{{ event.key | replace(".", "_") }}(const events::{{ event.cxx_class_name }}Event &event);{{ "\n\n    " if not loop.last }}{% endfor %}

    virtual ~Router() noexcept;
};

/// Router that logs everything on std::clog.
class NoisyRouter : public Router {
  public:
    {% for event in events %}/// Logs the "{{ event.key }}" event on std::clog.
    void on_{{ event.key | replace(".", "_") }}(const events::{{ event.cxx_class_name }}Event &event) override;{{ "\n\n    " if not loop.last }}{% endfor %}

    ~NoisyRouter() noexcept override;
};

} // namespace routers

/// Manages the lifecycle of a nettest. This API mirrors as closely as
/// possible to FFI API provided by <measurement_kit/ffi.h>.
class Nettest {
  public:
    // C++ object model
    // ````````````````

    /// Creates a nettest instance. This will not start the actual test. You
    /// need to use one of the start_XXX() methods to do that.
    Nettest() noexcept;

    /// Explicitly deleted copy constructor.
    Nettest(const Nettest &) noexcept = delete;

    /// Explicitly deleted copy assignment.
    Nettest &operator=(const Nettest &) noexcept = delete;

    /// Explicitly deleted move constructor.
    Nettest(Nettest &&) noexcept = delete;

    /// Explicitly deleted move assignment.
    Nettest &operator=(Nettest &&) noexcept = delete;

    /// Wait for nettest to terminate and destroy resources.
    ~Nettest() noexcept;

    // Starting a nettest
    // ``````````````````

    {% for nettest in nettests %}/// Starts a "{{ nettest.name }}" nettest.
    /// \param settings contains the settings configuring this nettest.
    /// \param router is the router used to route nettest events. If the
    /// router is `nullptr`, we'll use an internal dummy router.
    /// \return true on success, false on failure. There are two reasons why
    /// this method could fail. Either the provided settings are not JSON
    /// serializable because there was a string that was not valid UTF-8, or
    /// you already used this class to start a nettest. In both cases, log
    /// messages will be routed, so you will know what happened.
    bool start_{{ nettest.snake_case_name }}(settings::{{ nettest.name }}Settings settings, routers::Router *router) noexcept;{{ "\n\n    " if not loop.last }}{% endfor %}

    // Event processing methods
    // ````````````````````````

    /// Blocks until the next event occurs, then routes it.
    /// \param router Router to handle events. If the router is null, we'll
    /// use an internal dummy router.
    void route_next_event(routers::Router *router) noexcept;

    /// Returns true if nettest is done, false otherwise.
    bool is_done() noexcept;

    /// Interrupts the currently running nettest.
    void interrupt() noexcept;

  private:
    // Private methods
    // ```````````````

    // The default router used when no other router is available.
    static routers::Router *default_router() noexcept;

    // Internal method called to start any nettest.
    bool start_common(nlohmann::json, const settings::CommonSettings &, routers::Router *router) noexcept;

    // Private definitions
    // ```````````````````

    // Deleter for mk_task_t.
    class TaskDeleter {
      public:
        void operator()(mk_task_t *task) noexcept { mk_task_destroy(task); }
    };

    // Syntactic sugar of a unique mk_task_t pointer.
    using UniqueTask = std::unique_ptr<mk_task_t, TaskDeleter>;

    // Deleter for mk_event_t.
    class EventDeleter {
      public:
        void operator()(mk_event_t *event) noexcept { mk_event_destroy(event); }
    };

    // Syntactic sugar for a unique mk_event_t pointer.
    using UniqueEvent = std::unique_ptr<mk_event_t, EventDeleter>;

    // Private attributes
    // ``````````````````

    // Mutex used to protect the task_ attribute.
    std::mutex mutex_;

    // Unique pointer to the FFI task.
    UniqueTask task_;
};

/*-
 * __________        .__               __
 * \______   \_______|__|__  _______ _/  |_  ____
 *  |     ___/\_  __ \  \  \/ /\__  \\   __\/ __ \
 *  |    |     |  | \/  |\   /  / __ \|  | \  ___/
 *  |____|     |__|  |__| \_/  (____  /__|  \___  >
 *                                  \/          \/
 *
 * Definitions ends here. What follows is the inline implementation of this
 * API, which you can exclude by setting MK_NETTEST_NO_INLINE_IMPL.
 *
 * This is handy if you want to include this code in many translation
 * units to include the implementation into a single object.
 */
#if !defined MK_NETTEST_NO_INLINE_IMPL && !defined SWIG

// Routers
// -------

namespace routers {

{% for event in events %}void Router::on_{{ event.key | replace(".", "_") }}(const events::{{ event.cxx_class_name }}Event &) {}{{ "\n\n" if not loop.last }}{% endfor %}

Router::~Router() noexcept {}

{% for event in events %}void NoisyRouter::on_{{ event.key | replace(".", "_") }}(const events::{{ event.cxx_class_name }}Event &event) {
    std::clog << "{{ event.key }}:";
    {% if event.attributes %}{% for attribute in event.attributes %}std::clog << " {{ attribute.key }}='" << event.{{ attribute.key }} << "'";{{ "\n    " if not loop.last }}{% endfor %}{% else %}(void)event; /* No event attributes */{% endif %}
    std::clog << std::endl;
}{{ "\n\n" if not loop.last }}{% endfor %}

NoisyRouter::~NoisyRouter() noexcept {}

} // namespace routers

// Nettest
// -------

Nettest::Nettest() noexcept {}

Nettest::~Nettest() noexcept {}

{% for nettest in nettests %}bool Nettest::start_{{ nettest.snake_case_name }}(settings::{{ nettest.name }}Settings settings, routers::Router *router) noexcept {
    router = (router) ? router : default_router();
    nlohmann::json doc;
    doc["name"] = "{{ nettest.name }}";
    {% if nettest.attributes %}{% for attribute in nettest.attributes %}doc["options"]["{{ attribute.key}}"] = {{ attribute.cxx_cast_to_json }}settings.{{ attribute.key }};{{ "\n    " if not loop.last }}{% endfor %}{% else %}/* No nettest specific settings */{% endif %}
    return start_common(std::move(doc), settings, router);
}{{ "\n\n" if not loop.last }}{% endfor %}

void Nettest::route_next_event(routers::Router *router) noexcept {
    router = (router) ? router : default_router();
    UniqueEvent eventptr;
    nlohmann::json ev;
    {
        std::unique_lock<std::mutex> _{mutex_};
        eventptr.reset(mk_task_wait_for_next_event(task_.get()));
    }
    if (eventptr == nullptr) {
        // TODO(bassosimone): route this error.
        interrupt();
        return;
    }
    auto str = mk_event_serialize(eventptr.get());
    if (!str) {
        // TODO(bassosimone): route this error.
        interrupt();
        return;
    }
#ifdef MK_NETTEST_TRACE
    std::clog << "NETTEST: event: " << str << std::endl;
#endif
    try {
        ev = nlohmann::json::parse(str);
    } catch (const std::exception &) {
        // TODO(bassosimone): route this error.
        interrupt();
        return;
    }
    if (ev.count("key") <= 0 || !ev.at("key").is_string() || ev.count("value") <= 0 || !ev.at("value").is_object()) {
        // TODO(bassosimone): route this error.
        interrupt();
        return;
    }
    {% for event in events %}if (ev.at("key") == events::{{ event.cxx_class_name }}Event::key) {
        events::{{ event.cxx_class_name}}Event event;
        {% if event.attributes %}{% for attribute in event.attributes %}if (ev.count("{{ attribute.key }}") <= 0 || !ev.at("{{ attribute.key }}").is_{{ attribute.json_type }}()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.{{ attribute.key }} = {{ attribute.cxx_cast_from_json }}ev.at("value").at("{{ attribute.key }}");{{ "\n        " if not loop.last }}{% endfor %}{% else %}/* No attributes */{% endif %}
        router->on_{{ event.key | replace(".", "_") }}(event);
        return;
    }{{ "\n    " if not loop.last }}{% endfor %}
#ifdef MK_NETTEST_TRACE
    std::clog << "NETTEST: unhandled event: " << str << std::endl;
#endif
    // TODO(bassosimone): route this error.
    interrupt();
}

bool Nettest::is_done() noexcept {
    std::unique_lock<std::mutex> _{mutex_};
    return mk_task_is_done(task_.get());
}

void Nettest::interrupt() noexcept {
    std::unique_lock<std::mutex> _{mutex_};
    mk_task_interrupt(task_.get());
}

/* static */ routers::Router *Nettest::default_router() noexcept {
    static routers::Router router;
    return &router;
}

bool Nettest::start_common(nlohmann::json doc, const settings::CommonSettings &cs, routers::Router *router) noexcept {
    assert(router != nullptr);

    {% for setting in settings if not setting.internal %}doc["{{ setting.key }}"] = {{ setting.cxx_cast_to_json }}cs.{{ setting.key }};{{ "\n    " if not loop.last }}{% endfor %}
    {
        auto &o = doc["options"];
        {% for option in options %}o["{{ option.key }}"] = {{ option.cxx_cast_to_json }}cs.{{ option.key | replace("/", "_") }};{{ "\n        " if not loop.last }}{% endfor %}
    }

    std::unique_lock<std::mutex> _{mutex_};
    if (task_ != nullptr) {
        // TODO(bassosimone): route this error.
        return false;
    }
    std::string str;
    try {
        str = doc.dump();
    } catch (const std::exception &) {
        // TODO(bassosimone): route this error.
        return false;
    }
#ifdef MK_NETTEST_TRACE
    std::clog << "NETTEST: settings: " << str << std::endl;
#endif

    task_.reset(mk_task_start(str.c_str()));
    if (task_ == nullptr) {
        // TODO(bassosimone): route this error.
        return false;
    }
    return true;
}

#endif // !MK_NETTEST_NO_INLINE_IMPL && !SWIG
} // namespace nettest
} // namespace mk
#endif // MEASUREMENT_KIT_NETTEST_HPP

