#!/usr/bin/env python

""" Extract events specification from include/measurement_kit/README.md and
    generate the corresponding macros (<measurement_kit/nettests/events.hpp>)
    used by C++ code to process the events emitted by MK's ffi.h new API """

from __future__ import print_function

import json
import sys

if sys.version_info[0] == 3:
    STR = str
elif sys.version_info[0] == 2:
    STR = unicode
else:
    raise RuntimeError("unexpected major Python version")

def event_name_to_camel_case(name):
    """ Convert event name to class name """
    array = name.replace(".", "_").split("_")
    array = [elem.capitalize() for elem in array]
    return "".join(array)

def event_name_to_snake_case(name):
    """ Convert event name to class name """
    return name.replace(".", "_")

def main():
    """ Main function """
    outfile_path = "include/measurement_kit/nettests/events.hpp"
    sys.stderr.write("* Generating %s\n" % outfile_path)

    events = {}

    with open("include/measurement_kit/README.md", "r") as filep:
        current = []
        inside = False
        for line in filep:
            line = line.rstrip()
            if line == "```JSON":
                inside = True
                continue
            if inside and line == "```":
                inside = False
                evt = json.loads("".join(current))
                # Duck typing; we also have other JSONs in there
                if "key" in evt and "value" in evt:
                    events[evt["key"]] = evt["value"]
                del current[:]
                continue
            if not inside:
                continue
            current.append(line)

    # Remove the JSON showing the general events pattern. If we ever change
    # the file to remove, it following line of code will except.
    del events[u"<key>"]

    with open(outfile_path, "w") as filep:
        filep.write("// Auto-generated by %s; don't edit\n" % sys.argv[0])
        filep.write("#ifndef MEASUREMENT_KIT_NETTESTS_EVENTS_HPP\n")
        filep.write("#define MEASUREMENT_KIT_NETTESTS_EVENTS_HPP\n")
        filep.write("\n")
        filep.write("#include <assert.h>\n")
        filep.write("#include <stdint.h>\n")
        filep.write("\n")
        filep.write("#include <functional>\n")
        filep.write("#include <string>\n")
        filep.write("#include <utility>\n")
        filep.write("#include <vector>\n")
        filep.write("\n")
        filep.write("#include <measurement_kit/common/nlohmann/json.hpp>\n")
        filep.write("\n")
        filep.write("namespace mk {\n")
        filep.write("namespace nettests {\n")
        filep.write("\n")

        for key, value in sorted(events.items()):
            filep.write("/// C++ representation of '%s' event\n" % key)
            filep.write("class %s {\n" % event_name_to_camel_case(key))
            filep.write("  public:\n")
            for name, pattern in value.items():
                filep.write("    ")
                if isinstance(pattern, STR):
                    filep.write("std::string %s;\n" % name)
                elif isinstance(pattern, int):
                    filep.write("int64_t %s;\n" % name)
                elif isinstance(pattern, float):
                    filep.write("double %s;\n" % name)
                else:
                    raise RuntimeError("unexpected type for: %s" % pattern)
            filep.write("};\n\n")

        for key, value in sorted(events.items()):
            filep.write("/// Callback taking %s as unique argument\n" %
                        event_name_to_camel_case(key))
            filep.write("using %sCallback = std::function<void(%s)>;\n" % (
                event_name_to_camel_case(key), event_name_to_camel_case(key)))
            filep.write("\n")

        filep.write("/// Contains all the possible events callbacks\n")
        filep.write("class EventsCallbacks {\n")
        filep.write("  public:\n")
        for key, _ in sorted(events.items()):
            filep.write("\n")
            filep.write("    /// Callbacks for '%s' event\n" % key)
            filep.write("    std::vector<%sCallback> %s_cbs;\n" % (
                event_name_to_camel_case(key), event_name_to_snake_case(key)))
        filep.write("};\n\n")

        filep.write("/// Statuses returned by EventsRouter::route() call\n")
        filep.write("class RouteStatus {\n")
        filep.write("  public:\n")
        filep.write("    bool success;         ///< Success flag\n")
        filep.write("    std::string reason;   ///< Related reason\n")
        filep.write("\n")
        filep.write("    /// Constructor with success flag and reason\n")
        filep.write("    RouteStatus(bool success, std::string reason) noexcept {\n")
        filep.write("        this->success = success;\n")
        filep.write("        this->reason = reason;\n")
        filep.write("    }\n")
        filep.write("\n")
        filep.write("    /// Implicit conversion to boolean\n")
        filep.write("    operator bool() const noexcept {\n")
        filep.write("        return success;\n")
        filep.write("    }\n")
        filep.write("};\n\n")

        filep.write("/// Exceptions emitted by JSON library\n")
        filep.write("#if NLOHMANN_JSON_VERSION_MAJOR >= 3\n")
        filep.write("using NlohmannJsonException = nlohmann::json::exception;\n")
        filep.write("#else\n")
        filep.write("using NlohmannJsonException = std::exception;\n")
        filep.write("#endif\n\n")

        filep.write("/// Routes events to callbacks\n")
        filep.write("class EventsRouter {\n")
        filep.write("  public:\n")
        filep.write("    /// Constructor with specific callbacks\n")
        filep.write("    explicit EventsRouter(EventsCallbacks &&cbs) noexcept {\n")
        filep.write("        std::swap(cbs, cbs_);\n")
        filep.write("    }\n")
        filep.write("\n")
        filep.write("    /// Deleted copy constructor\n")
        filep.write("    EventsRouter(const EventsRouter &) noexcept = delete;\n")
        filep.write("\n")
        filep.write("    /// Deleted copy assignment operator\n")
        filep.write("    EventsRouter &operator=(const EventsRouter &) noexcept = delete;\n")
        filep.write("\n")
        filep.write("    /// Defaulted move constructor\n")
        filep.write("    EventsRouter(EventsRouter &&) noexcept = default;\n")
        filep.write("\n")
        filep.write("    /// Defaulted move assignment operator\n")
        filep.write("    EventsRouter &operator=(EventsRouter &&) noexcept = default;\n")
        filep.write("\n")
        filep.write("    /// Defaulted destructor\n")
        filep.write("    ~EventsRouter() noexcept = default;\n")
        filep.write("\n")
        filep.write("    /// Routes event @p s to a specific callback\n")
        filep.write("    RouteStatus route(const char *s) const noexcept {\n")
        filep.write("       assert(!!s);\n")
        filep.write("       nlohmann::json event;\n")
        filep.write("\n")
        filep.write("       try {\n")
        filep.write("           event = nlohmann::json::parse(s);\n")
        filep.write("       } catch (const NlohmannJsonException &exc) {\n")
        filep.write("           return {false, exc.what()};\n")
        filep.write("       }\n")
        filep.write("\n")
        filep.write("       if (!event.is_object()) {\n")
        filep.write("           return {false, \"not_an_object\"};\n")
        filep.write("       }\n")
        filep.write("       if (event.count(\"key\") <= 0) {\n")
        filep.write("           return {false, \"missing_entry: key\"};\n")
        filep.write("       }\n")
        filep.write("       if (!event.at(\"key\").is_string()) {\n")
        filep.write("           return {false, \"invalid_entry: key\"};\n")
        filep.write("       }\n")
        filep.write("       if (!event.count(\"value\")) {\n")
        filep.write("           return {false, \"missing_entry: value\"};\n")
        filep.write("       }\n")
        filep.write("       if (!event.at(\"value\").is_object()) {\n")
        filep.write("           return {false, \"invalid_entry: value\"};\n")
        filep.write("       }\n")
        filep.write("       std::string key = event.at(\"key\");\n")
        filep.write("       const nlohmann::json &value = event.at(\"value\");\n")
        filep.write("\n")
        for key, value in sorted(events.items()):
            filep.write("       if (key == \"%s\") {\n" % key)
            filep.write("           %s data;\n" % event_name_to_camel_case(key))
            if value:
                for name, _ in value.items():
                    filep.write("           if (value.count(\"%s\") <= 0) {\n" % name)
                    filep.write("               return {false, \"missing_entry: %s\"};\n" % name)
                    filep.write("           }\n")
                    filep.write("           try {\n")
                    filep.write("               ")
                    filep.write("data.%s = value.at(\"%s\");\n" % (name, name))
                    filep.write("           } catch (const NlohmannJsonException &exc) {\n")
                    filep.write("               return {false, exc.what()};\n")
                    filep.write("           }\n")
            filep.write("           for (auto &cb : cbs_.%s_cbs) {\n"
                        % event_name_to_snake_case(key))
            filep.write("               cb(data);\n")
            filep.write("           }\n")
            filep.write("           return {true, \"\"};\n")
            filep.write("       }\n\n")
        filep.write("       std::string reason = \"unknown_key: \";\n")
        filep.write("       reason += key;\n")
        filep.write("       return {false, std::move(reason)};\n")
        filep.write("    }\n")
        filep.write("\n")
        filep.write("  private:\n")
        filep.write("    EventsCallbacks cbs_;\n")
        filep.write("};\n")
        filep.write("\n")

        filep.write("} // namespace nettests\n")
        filep.write("} // namespace mk\n")
        filep.write("#endif // MEASUREMENT_KIT_NETTESTS_EVENTS_HPP\n")

if __name__ == "__main__":
    main()
