#!/usr/bin/env python

""" Extracts MK FFI's specifications from the
    `include/measurement_kit/README.md` file and generates the corresponding
    C++11 wrappers into the `include/measurement_kit/cxx14/all.hpp` file. """

from __future__ import print_function

import json
import re
import sys

if sys.version_info[0] == 3:
    STR = str
elif sys.version_info[0] == 2:
    STR = unicode
else:
    raise RuntimeError("unexpected major Python version")

def event_name_to_camel_case(name):
    """ Convert event name to camel case """
    array = name.replace(".", "_").split("_")
    array = [elem.capitalize() for elem in array]
    return "".join(array)

def event_name_to_snake_case(name):
    """ Convert event name to snake case """
    return name.replace(".", "_")

def option_name_to_snake_case(name):
    """ Convert option name to snake case """
    return name.replace("/", "_")

def gather_events_info():
    """ Gathers info on events """
    events = {}
    with open("include/measurement_kit/README.md", "r") as filep:
        current = []
        inside = False
        for line in filep:
            line = line.rstrip()
            if line == "```JSON":
                inside = True
                continue
            if inside and line == "```":
                inside = False
                doc = json.loads("".join(current))
                # Duck typing; we also have other JSONs in there
                if "key" in doc and "value" in doc:
                    events[doc["key"]] = doc["value"]
                del current[:]
                continue
            if not inside:
                continue
            current.append(line)
    # Remove the JSON showing the general events pattern. If we ever change
    # the file to remove, it following line of code will except.
    del events[u"<key>"]
    return events

def gather_settings_info():
    """ Gathers info on settings """
    settings = []
    with open("include/measurement_kit/README.md", "r") as filep:
        current = []
        inside = False
        for line in filep:
            line = line.rstrip()
            if line == "```JSON":
                inside = True
                continue
            if inside and line == "```":
                inside = False
                doc = json.loads("".join(current))
                # Duck typing; we also have other JSONs in there
                if "annotations" in doc and "name" in doc:
                    settings.append(doc)
                del current[:]
                continue
            if not inside:
                continue
            current.append(line)
    assert(len(settings) == 1) # We must have one setting-like JSON
    return settings[0]

def gather_sections_info():
    """ Gather info on sections """
    re_spec = r'^- `"([._/A-Za-z0-9]+)"`: (\((array|float|int|object|string)(;\ *(mandatory|optional))*\))?'
    sections = {}
    with open("include/measurement_kit/README.md", "rb") as filep:
        section = None
        for line in filep:
            line = line.rstrip()
            # Change section we're in
            if (line == "## Tasks" or line == "## Settings" 
                or line == "## Log levels" or line == "## Options"
                or line == "## Events"):
                line = line.replace("## ", "").replace(" ", "_").lower()
                section = line
            # Extract documentation related to a section
            if section and line.startswith('- `"'):
                match = re.match(re_spec, line)
                if not match:
                    continue
                name = match.group(1)
                datatype = "string"
                if match.group(3):
                    datatype = match.group(3)
                mandatory = False
                if match.group(5):
                    mandatory = match.group(5) == "mandatory"
                spec = name, datatype, mandatory
                sections.setdefault(section, [])
                sections[section].append(spec)
    return sections

def write_header_prologue(filep):
    """ Writes the prologue of the header file """
    filep.write("// Auto-generated by %s; don't edit\n" % sys.argv[0])
    filep.write("#ifndef MEASUREMENT_KIT_CXX14_ALL_HPP\n")
    filep.write("#define MEASUREMENT_KIT_CXX14_ALL_HPP\n")
    filep.write("\n")
    filep.write("#include <assert.h>\n")
    filep.write("#include <stdint.h>\n")
    filep.write("\n")
    filep.write("#include <functional>\n")
    filep.write("#include <memory>\n")
    filep.write("#include <string>\n")
    filep.write("#include <thread>\n")
    filep.write("#include <utility>\n")
    filep.write("#include <vector>\n")
    filep.write("\n")
    filep.write("#include <measurement_kit/common/nlohmann/json.hpp>\n")
    filep.write("#include <measurement_kit/ffi.h>\n")
    filep.write("\n")
    filep.write("namespace mk {\n")
    filep.write("namespace cxx14 {\n")
    filep.write("\n")

def write_ffi_helpers(filep):
    """ Writes helpers to handle FFI types """
    filep.write("/// Deletes a mk_task_t pointer\n")
    filep.write("class TaskDeleter {\n")
    filep.write("  public:\n")
    filep.write("    void operator()(mk_task_t *task) noexcept { mk_task_destroy(task); }\n")
    filep.write("};\n")
    filep.write("\n")
    filep.write("/// Unique pointer to mk_task_t\n")
    filep.write("using TaskUptr = std::unique_ptr<mk_task_t, TaskDeleter>;\n")
    filep.write("\n")
    filep.write("/// Deletes a mk_event_t pointer\n")
    filep.write("class EventDeleter {\n")
    filep.write("  public:\n")
    filep.write("    void operator()(mk_event_t *event) noexcept { mk_event_destroy(event); }\n")
    filep.write("};\n")
    filep.write("\n")
    filep.write("/// Unique pointer to mk_event_t\n")
    filep.write("using EventUptr = std::unique_ptr<mk_event_t, EventDeleter>;\n")
    filep.write("\n")

def write_events_classes(filep, events):
    """ Writes event classes on the header file """
    for key, value in sorted(events.items()):
        filep.write("/// C++ representation of '%s' event\n" % key)
        filep.write("class %s {\n" % event_name_to_camel_case(key))
        filep.write("  public:\n")
        for name, pattern in value.items():
            filep.write("    ")
            if isinstance(pattern, STR):
                filep.write("std::string %s;\n" % name)
            elif isinstance(pattern, int):
                filep.write("int64_t %s = 0;\n" % name)
            elif isinstance(pattern, float):
                filep.write("double %s = 0.0;\n" % name)
            else:
                raise RuntimeError("unexpected type for: %s" % pattern)
        filep.write("};\n\n")

def write_events_callbacks(filep, events):
    """ Writes events callbacks in the header file """
    for key, value in sorted(events.items()):
        filep.write("/// Callback taking `const %s &` as unique argument\n" %
                    event_name_to_camel_case(key))
        filep.write("using %sCallback = std::function<void(const %s &)>;\n" % (
            event_name_to_camel_case(key), event_name_to_camel_case(key)))
        filep.write("\n")

def write_taskinfo_class(filep, settings, sections, events):
    filep.write("/// Info on a generic task\n")
    filep.write("class TaskInfo {\n")
    filep.write("  public:\n")
    for name in sorted(settings.keys()):
        value, omit_nl = settings[name], False
        filep.write("    /// '%s' field of settings\n" % name)
        if isinstance(value, list):
            filep.write("    std::vector<std::string> %s;\n" % name)
            filep.write("\n")
            filep.write("    /// Allows to append to '%s' using method chaining\n" % name)
            singular_name = name
            if singular_name.endswith("s"):
                singular_name = singular_name[:-1]
            filep.write("    TaskInfo &add_%s(const std::string &s) noexcept {\n" % singular_name)
            filep.write("        %s.push_back(s);\n" % name)
            filep.write("        return *this;\n")
            filep.write("    }\n")
        elif isinstance(value, dict):
            filep.write("    nlohmann::json %s;\n" % name)
            filep.write("\n")
            for var in ("double v", "int64_t v", "const std::string &v"):
                filep.write("    /// Allows to set %s using method chaining\n" % name[:-1])
                filep.write("    TaskInfo &set_%s(const std::string &k, %s) noexcept {\n" % (name[:-1], var))
                filep.write("        %s[k] = v;\n" % name)
                filep.write("        return *this;\n")
                filep.write("    }\n")
                filep.write("\n")
            if name == "options":  # Options deserve special processing
                for oname, otype, _ in sorted(sections["options"]):
                    filep.write("    /// Allows to set '%s' option using method chaining\n" % oname)
                    if otype == "float":
                        otype = "double v"
                    elif otype == "int":
                        otype = "int64_t v"
                    elif otype == "string":
                        otype = "const std::string &v"
                    else:
                        raise RuntimeError("unexpected option type: %s" % otype)
                    filep.write("    TaskInfo &set_%s_option(%s) noexcept {\n" % (
                                option_name_to_snake_case(oname), otype))
                    filep.write("        options[\"%s\"] = v;\n" % oname)
                    filep.write("        return *this;\n")
                    filep.write("    }\n")
                    filep.write("\n")
            omit_nl = True
        elif isinstance(value, STR):
            filep.write("    std::string %s;\n" % name)
            filep.write("\n")
            filep.write("    /// Allows to set '%s' using method chaining\n" % name)
            filep.write("    TaskInfo &set_%s(const std::string &s) noexcept {\n" % name)
            filep.write("        %s = s;\n" % name)
            filep.write("        return *this;\n")
            filep.write("    }\n")
        elif isinstance(value, float):
            filep.write("    double %s;\n" % name)
        elif isinstance(value, int):
            filep.write("    int64_t %s;\n" % name)
        else:
            raise RuntimeError("unexpected type for: %s" % value)
        if not omit_nl:
            filep.write("\n")
    for key in sorted(events.keys()):
        filep.write("    /// Callbacks for '%s' event\n" % key)
        filep.write("    std::vector<%sCallback> %s_cbs;\n" % (
            event_name_to_camel_case(key), event_name_to_snake_case(key)))
        filep.write("\n")
        filep.write("    /// Allows to add callback for '%s' event using method chaining\n" % key)
        filep.write("    TaskInfo &on_%s(%sCallback &&cb) noexcept {\n" % (
            event_name_to_snake_case(key), event_name_to_camel_case(key)))
        filep.write("        %s_cbs.push_back(std::move(cb));\n" % event_name_to_snake_case(key))
        filep.write("        return *this;\n")
        filep.write("    }\n")
        filep.write("\n")
    for index, tpl in enumerate(sorted(sections["tasks"])):
        name = tpl[0]
        filep.write("    /// Factory method for creating a '%s' task\n" % (name))
        filep.write("    static TaskInfo %s() noexcept {\n" % name)
        filep.write("        TaskInfo info;\n")
        filep.write("        info.name = \"%s\";\n" % name)
        filep.write("        return info;\n")
        filep.write("    };\n")
        if index < len(sections["tasks"]) - 1:
            filep.write("\n")
    filep.write("};\n")
    filep.write("\n")

def write_nlohmann_json_exception(filep):
    """ Writes the NlohmannJsonException class """
    filep.write("/// Exceptions emitted by JSON library\n")
    filep.write("#if NLOHMANN_JSON_VERSION_MAJOR >= 3\n")
    filep.write("using NlohmannJsonException = nlohmann::json::exception;\n")
    filep.write("#else\n")
    filep.write("using NlohmannJsonException = std::exception;\n")
    filep.write("#endif\n\n")

def write_runner(filep, settings, events):
    """ Writes the runner class """
    filep.write("/// Runs a task\n")
    filep.write("class TaskRunner {\n")
    filep.write("  public:\n")
    filep.write("    /// Runs the specified task in the current thread\n")
    filep.write("    bool run(TaskInfo &&info) const noexcept {\n")
    filep.write("        nlohmann::json doc;\n")
    for name in sorted(settings.keys()):
        filep.write("        doc[\"%s\"] = info.%s;\n" % (name, name))
    filep.write("        std::string settings;\n")
    filep.write("        try {\n")
    filep.write("            settings = doc.dump();\n")
    filep.write("        } catch (const NlohmannJsonException &) {\n")
    filep.write("            return false;\n")
    filep.write("        }\n")
    filep.write("        TaskUptr ptask;\n")
    filep.write("        ptask.reset(mk_task_start(settings.c_str()));\n")
    filep.write("        if (!ptask) {\n")
    filep.write("            return false;\n")
    filep.write("        }\n")
    filep.write("        auto rv = true;\n")
    filep.write("        while (rv && !mk_task_is_done(ptask.get())) {\n")
    filep.write("            EventUptr pevent;\n")
    filep.write("            pevent.reset(mk_task_wait_for_next_event(ptask.get()));\n")
    filep.write("            if (!pevent) {\n")
    filep.write("                rv = false;\n")
    filep.write("                break;\n")
    filep.write("            }\n")
    filep.write("            auto pstr = mk_event_serialize(pevent.get());\n")
    filep.write("            if (!pstr) {\n")
    filep.write("                assert(false);\n")
    filep.write("                rv = false;\n")
    filep.write("                break;\n")
    filep.write("            }\n")
    filep.write("            nlohmann::json event;\n")
    filep.write("            try {\n")
    filep.write("                event = nlohmann::json::parse(pstr);\n")
    filep.write("            } catch (const NlohmannJsonException &) {\n")
    filep.write("                assert(false);\n")
    filep.write("                rv = false;\n")
    filep.write("                break;\n")
    filep.write("            }\n")
    filep.write("            rv = process_event(info, event);\n")
    filep.write("        }\n")
    filep.write("        if (!rv) {\n")
    filep.write("            mk_task_interrupt(ptask.get());\n")
    filep.write("        }\n")
    filep.write("        return rv;\n")
    filep.write("    }\n")
    filep.write("\n")
    filep.write("    bool process_event(const TaskInfo &info, const nlohmann::json &event) const noexcept {\n")
    filep.write("       if (!event.is_object()) {\n")
    filep.write("           return false;\n")
    filep.write("       }\n")
    filep.write("       if (event.count(\"key\") <= 0) {\n")
    filep.write("           return false;\n")
    filep.write("       }\n")
    filep.write("       if (!event.at(\"key\").is_string()) {\n")
    filep.write("           return false;\n")
    filep.write("       }\n")
    filep.write("       if (!event.count(\"value\")) {\n")
    filep.write("           return false;\n")
    filep.write("       }\n")
    filep.write("       if (!event.at(\"value\").is_object()) {\n")
    filep.write("           return false;\n")
    filep.write("       }\n")
    filep.write("       const std::string &key = event.at(\"key\");\n")
    filep.write("       const nlohmann::json &value = event.at(\"value\");\n")
    filep.write("\n")
    for key, value in sorted(events.items()):
        filep.write("       if (key == \"%s\") {\n" % key)
        filep.write("           %s data;\n" % event_name_to_camel_case(key))
        if value:
            for name, _ in value.items():
                filep.write("           if (value.count(\"%s\") <= 0) {\n" % name)
                filep.write("               return false;\n")
                filep.write("           }\n")
                filep.write("           try {\n")
                filep.write("               data.%s = value.at(\"%s\");\n" % (name, name))
                filep.write("           } catch (const NlohmannJsonException &exc) {\n")
                filep.write("               return false;\n")
                filep.write("           }\n")
        filep.write("           for (auto &cb : info.%s_cbs) {\n" % event_name_to_snake_case(key))
        filep.write("               cb(data);\n")
        filep.write("           }\n")
        filep.write("           return true;\n")
        filep.write("       }\n\n")
    filep.write("       return false;\n")
    filep.write("    }\n")
    filep.write("\n")
    filep.write("    /// Start a task in a background thread\n")
    filep.write("    void start(TaskInfo &&info, std::function<void()> &&cb) const noexcept {\n")
    filep.write("        std::thread thread{[this, info = std::move(info), cb = std::move(cb)]() mutable noexcept {\n")
    filep.write("            run(std::move(info));\n")
    filep.write("            cb();\n")
    filep.write("        }};\n")
    filep.write("    }\n")
    filep.write("\n")
    filep.write("    /// Factory to obtain the global runner\n")
    filep.write("    static const TaskRunner &global() noexcept {\n")
    filep.write("        static TaskRunner runner;\n")
    filep.write("        return runner;\n")
    filep.write("    }\n")
    filep.write("};\n")
    filep.write("\n")

def write_header_epilogue(filep):
    """ write header epilogue """
    filep.write("} // namespace cxx14\n")
    filep.write("} // namespace mk\n")
    filep.write("#endif // MEASUREMENT_KIT_CXX14_ALL_HPP\n")

def main():
    """ Main function """
    outfile_path = "include/measurement_kit/cxx14/all.hpp"
    sys.stderr.write("* Generating %s\n" % outfile_path)

    sections = gather_sections_info()
    events = gather_events_info()
    settings = gather_settings_info()

    # TODO(bassosimone): add cross check between settings and sections

    with open(outfile_path, "w") as filep:
        write_header_prologue(filep)
        write_ffi_helpers(filep)
        write_events_classes(filep, events)
        write_events_callbacks(filep, events)
        write_taskinfo_class(filep, settings, sections, events)
        write_nlohmann_json_exception(filep)
        write_runner(filep, settings, events)
        write_header_epilogue(filep)

if __name__ == "__main__":
    main()
