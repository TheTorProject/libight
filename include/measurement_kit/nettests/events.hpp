// Auto-generated by ./script/gen/nettests/events; don't edit
#ifndef MEASUREMENT_KIT_NETTESTS_EVENTS_HPP
#define MEASUREMENT_KIT_NETTESTS_EVENTS_HPP

#include <assert.h>
#include <stdint.h>

#include <functional>
#include <string>
#include <utility>
#include <vector>

#include <measurement_kit/common/nlohmann/json.hpp>

namespace mk {
namespace nettests {

/// C++ representation of 'failure.asn_lookup' event
class FailureAsnLookup {
  public:
    std::string failure;
};

/// C++ representation of 'failure.cc_lookup' event
class FailureCcLookup {
  public:
    std::string failure;
};

/// C++ representation of 'failure.ip_lookup' event
class FailureIpLookup {
  public:
    std::string failure;
};

/// C++ representation of 'failure.measurement' event
class FailureMeasurement {
  public:
    std::string failure;
};

/// C++ representation of 'failure.measurement_submission' event
class FailureMeasurementSubmission {
  public:
    std::string failure;
    std::string json_str;
    int64_t idx;
};

/// C++ representation of 'failure.report_close' event
class FailureReportClose {
  public:
    std::string failure;
};

/// C++ representation of 'failure.report_create' event
class FailureReportCreate {
  public:
    std::string failure;
};

/// C++ representation of 'failure.resolver_lookup' event
class FailureResolverLookup {
  public:
    std::string failure;
};

/// C++ representation of 'failure.startup' event
class FailureStartup {
  public:
    std::string failure;
};

/// C++ representation of 'log' event
class Log {
  public:
    std::string message;
    std::string log_level;
};

/// C++ representation of 'measurement' event
class Measurement {
  public:
    std::string json_str;
    int64_t idx;
};

/// C++ representation of 'status.end' event
class StatusEnd {
  public:
    std::string failure;
    double uploaded_kb;
    double downloaded_kb;
};

/// C++ representation of 'status.geoip_lookup' event
class StatusGeoipLookup {
  public:
    std::string probe_ip;
    std::string probe_network_name;
    std::string probe_asn;
    std::string probe_cc;
};

/// C++ representation of 'status.measurement_done' event
class StatusMeasurementDone {
  public:
    int64_t idx;
};

/// C++ representation of 'status.measurement_start' event
class StatusMeasurementStart {
  public:
    std::string input;
    int64_t idx;
};

/// C++ representation of 'status.measurement_submission' event
class StatusMeasurementSubmission {
  public:
    int64_t idx;
};

/// C++ representation of 'status.progress' event
class StatusProgress {
  public:
    double percentage;
    std::string message;
};

/// C++ representation of 'status.queued' event
class StatusQueued {
  public:
};

/// C++ representation of 'status.report_close' event
class StatusReportClose {
  public:
    std::string report_id;
};

/// C++ representation of 'status.report_create' event
class StatusReportCreate {
  public:
    std::string report_id;
};

/// C++ representation of 'status.resolver_lookup' event
class StatusResolverLookup {
  public:
    std::string resolver_ip;
};

/// C++ representation of 'status.started' event
class StatusStarted {
  public:
};

/// C++ representation of 'status.terminated' event
class StatusTerminated {
  public:
};

/// C++ representation of 'status.update.performance' event
class StatusUpdatePerformance {
  public:
    std::string direction;
    int64_t num_streams;
    double speed_kbps;
    double elapsed;
};

/// C++ representation of 'status.update.websites' event
class StatusUpdateWebsites {
  public:
    std::string url;
    std::string status;
};

/// Callback taking FailureAsnLookup as unique argument
using FailureAsnLookupCallback = std::function<void(FailureAsnLookup)>;

/// Callback taking FailureCcLookup as unique argument
using FailureCcLookupCallback = std::function<void(FailureCcLookup)>;

/// Callback taking FailureIpLookup as unique argument
using FailureIpLookupCallback = std::function<void(FailureIpLookup)>;

/// Callback taking FailureMeasurement as unique argument
using FailureMeasurementCallback = std::function<void(FailureMeasurement)>;

/// Callback taking FailureMeasurementSubmission as unique argument
using FailureMeasurementSubmissionCallback = std::function<void(FailureMeasurementSubmission)>;

/// Callback taking FailureReportClose as unique argument
using FailureReportCloseCallback = std::function<void(FailureReportClose)>;

/// Callback taking FailureReportCreate as unique argument
using FailureReportCreateCallback = std::function<void(FailureReportCreate)>;

/// Callback taking FailureResolverLookup as unique argument
using FailureResolverLookupCallback = std::function<void(FailureResolverLookup)>;

/// Callback taking FailureStartup as unique argument
using FailureStartupCallback = std::function<void(FailureStartup)>;

/// Callback taking Log as unique argument
using LogCallback = std::function<void(Log)>;

/// Callback taking Measurement as unique argument
using MeasurementCallback = std::function<void(Measurement)>;

/// Callback taking StatusEnd as unique argument
using StatusEndCallback = std::function<void(StatusEnd)>;

/// Callback taking StatusGeoipLookup as unique argument
using StatusGeoipLookupCallback = std::function<void(StatusGeoipLookup)>;

/// Callback taking StatusMeasurementDone as unique argument
using StatusMeasurementDoneCallback = std::function<void(StatusMeasurementDone)>;

/// Callback taking StatusMeasurementStart as unique argument
using StatusMeasurementStartCallback = std::function<void(StatusMeasurementStart)>;

/// Callback taking StatusMeasurementSubmission as unique argument
using StatusMeasurementSubmissionCallback = std::function<void(StatusMeasurementSubmission)>;

/// Callback taking StatusProgress as unique argument
using StatusProgressCallback = std::function<void(StatusProgress)>;

/// Callback taking StatusQueued as unique argument
using StatusQueuedCallback = std::function<void(StatusQueued)>;

/// Callback taking StatusReportClose as unique argument
using StatusReportCloseCallback = std::function<void(StatusReportClose)>;

/// Callback taking StatusReportCreate as unique argument
using StatusReportCreateCallback = std::function<void(StatusReportCreate)>;

/// Callback taking StatusResolverLookup as unique argument
using StatusResolverLookupCallback = std::function<void(StatusResolverLookup)>;

/// Callback taking StatusStarted as unique argument
using StatusStartedCallback = std::function<void(StatusStarted)>;

/// Callback taking StatusTerminated as unique argument
using StatusTerminatedCallback = std::function<void(StatusTerminated)>;

/// Callback taking StatusUpdatePerformance as unique argument
using StatusUpdatePerformanceCallback = std::function<void(StatusUpdatePerformance)>;

/// Callback taking StatusUpdateWebsites as unique argument
using StatusUpdateWebsitesCallback = std::function<void(StatusUpdateWebsites)>;

/// Contains all the possible events callbacks
class EventsCallbacks {
  public:

    /// Callbacks for 'failure.asn_lookup' event
    std::vector<FailureAsnLookupCallback> failure_asn_lookup_cbs;

    /// Callbacks for 'failure.cc_lookup' event
    std::vector<FailureCcLookupCallback> failure_cc_lookup_cbs;

    /// Callbacks for 'failure.ip_lookup' event
    std::vector<FailureIpLookupCallback> failure_ip_lookup_cbs;

    /// Callbacks for 'failure.measurement' event
    std::vector<FailureMeasurementCallback> failure_measurement_cbs;

    /// Callbacks for 'failure.measurement_submission' event
    std::vector<FailureMeasurementSubmissionCallback> failure_measurement_submission_cbs;

    /// Callbacks for 'failure.report_close' event
    std::vector<FailureReportCloseCallback> failure_report_close_cbs;

    /// Callbacks for 'failure.report_create' event
    std::vector<FailureReportCreateCallback> failure_report_create_cbs;

    /// Callbacks for 'failure.resolver_lookup' event
    std::vector<FailureResolverLookupCallback> failure_resolver_lookup_cbs;

    /// Callbacks for 'failure.startup' event
    std::vector<FailureStartupCallback> failure_startup_cbs;

    /// Callbacks for 'log' event
    std::vector<LogCallback> log_cbs;

    /// Callbacks for 'measurement' event
    std::vector<MeasurementCallback> measurement_cbs;

    /// Callbacks for 'status.end' event
    std::vector<StatusEndCallback> status_end_cbs;

    /// Callbacks for 'status.geoip_lookup' event
    std::vector<StatusGeoipLookupCallback> status_geoip_lookup_cbs;

    /// Callbacks for 'status.measurement_done' event
    std::vector<StatusMeasurementDoneCallback> status_measurement_done_cbs;

    /// Callbacks for 'status.measurement_start' event
    std::vector<StatusMeasurementStartCallback> status_measurement_start_cbs;

    /// Callbacks for 'status.measurement_submission' event
    std::vector<StatusMeasurementSubmissionCallback> status_measurement_submission_cbs;

    /// Callbacks for 'status.progress' event
    std::vector<StatusProgressCallback> status_progress_cbs;

    /// Callbacks for 'status.queued' event
    std::vector<StatusQueuedCallback> status_queued_cbs;

    /// Callbacks for 'status.report_close' event
    std::vector<StatusReportCloseCallback> status_report_close_cbs;

    /// Callbacks for 'status.report_create' event
    std::vector<StatusReportCreateCallback> status_report_create_cbs;

    /// Callbacks for 'status.resolver_lookup' event
    std::vector<StatusResolverLookupCallback> status_resolver_lookup_cbs;

    /// Callbacks for 'status.started' event
    std::vector<StatusStartedCallback> status_started_cbs;

    /// Callbacks for 'status.terminated' event
    std::vector<StatusTerminatedCallback> status_terminated_cbs;

    /// Callbacks for 'status.update.performance' event
    std::vector<StatusUpdatePerformanceCallback> status_update_performance_cbs;

    /// Callbacks for 'status.update.websites' event
    std::vector<StatusUpdateWebsitesCallback> status_update_websites_cbs;
};

/// Statuses returned by EventsRouter::route() call
class RouteStatus {
  public:
    bool success;         ///< Success flag
    std::string reason;   ///< Related reason

    /// Constructor with success flag and reason
    RouteStatus(bool success, std::string reason) noexcept {
        this->success = success;
        this->reason = reason;
    }

    /// Implicit conversion to boolean
    operator bool() const noexcept {
        return success;
    }
};

/// Exceptions emitted by JSON library
#if NLOHMANN_JSON_VERSION_MAJOR >= 3
using NlohmannJsonException = nlohmann::json::exception;
#else
using NlohmannJsonException = std::exception;
#endif

/// Routes events to callbacks
class EventsRouter {
  public:
    /// Default constructor
    EventsRouter() noexcept {}

    /// Constructor with specific callbacks
    explicit EventsRouter(EventsCallbacks &&cbs) noexcept {
        std::swap(cbs, cbs_);
    }

    /// Deleted copy constructor
    EventsRouter(const EventsRouter &) noexcept = delete;

    /// Deleted copy assignment operator
    EventsRouter &operator=(const EventsRouter &) noexcept = delete;

    /// Defaulted move constructor
    EventsRouter(EventsRouter &&) noexcept = default;

    /// Defaulted move assignment operator
    EventsRouter &operator=(EventsRouter &&) noexcept = default;

    /// Defaulted destructor
    ~EventsRouter() noexcept = default;

    /// Routes event @p s to a specific callback
    RouteStatus route(const char *s) const noexcept {
       assert(!!s);
       nlohmann::json event;

       try {
           event = nlohmann::json::parse(s);
       } catch (const NlohmannJsonException &exc) {
           return {false, exc.what()};
       }

       if (!event.is_object()) {
           return {false, "not_an_object"};
       }
       if (event.count("key") <= 0) {
           return {false, "missing_entry: key"};
       }
       if (!event.at("key").is_string()) {
           return {false, "invalid_entry: key"};
       }
       if (!event.count("value")) {
           return {false, "missing_entry: value"};
       }
       if (!event.at("value").is_object()) {
           return {false, "invalid_entry: value"};
       }
       std::string key = event.at("key");
       const nlohmann::json &value = event.at("value");

       if (key == "failure.asn_lookup") {
           FailureAsnLookup data;
           if (value.count("failure") <= 0) {
               return {false, "missing_entry: failure"};
           }
           try {
               data.failure = value.at("failure");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           for (auto &cb : cbs_.failure_asn_lookup_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "failure.cc_lookup") {
           FailureCcLookup data;
           if (value.count("failure") <= 0) {
               return {false, "missing_entry: failure"};
           }
           try {
               data.failure = value.at("failure");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           for (auto &cb : cbs_.failure_cc_lookup_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "failure.ip_lookup") {
           FailureIpLookup data;
           if (value.count("failure") <= 0) {
               return {false, "missing_entry: failure"};
           }
           try {
               data.failure = value.at("failure");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           for (auto &cb : cbs_.failure_ip_lookup_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "failure.measurement") {
           FailureMeasurement data;
           if (value.count("failure") <= 0) {
               return {false, "missing_entry: failure"};
           }
           try {
               data.failure = value.at("failure");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           for (auto &cb : cbs_.failure_measurement_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "failure.measurement_submission") {
           FailureMeasurementSubmission data;
           if (value.count("failure") <= 0) {
               return {false, "missing_entry: failure"};
           }
           try {
               data.failure = value.at("failure");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           if (value.count("json_str") <= 0) {
               return {false, "missing_entry: json_str"};
           }
           try {
               data.json_str = value.at("json_str");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           if (value.count("idx") <= 0) {
               return {false, "missing_entry: idx"};
           }
           try {
               data.idx = value.at("idx");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           for (auto &cb : cbs_.failure_measurement_submission_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "failure.report_close") {
           FailureReportClose data;
           if (value.count("failure") <= 0) {
               return {false, "missing_entry: failure"};
           }
           try {
               data.failure = value.at("failure");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           for (auto &cb : cbs_.failure_report_close_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "failure.report_create") {
           FailureReportCreate data;
           if (value.count("failure") <= 0) {
               return {false, "missing_entry: failure"};
           }
           try {
               data.failure = value.at("failure");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           for (auto &cb : cbs_.failure_report_create_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "failure.resolver_lookup") {
           FailureResolverLookup data;
           if (value.count("failure") <= 0) {
               return {false, "missing_entry: failure"};
           }
           try {
               data.failure = value.at("failure");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           for (auto &cb : cbs_.failure_resolver_lookup_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "failure.startup") {
           FailureStartup data;
           if (value.count("failure") <= 0) {
               return {false, "missing_entry: failure"};
           }
           try {
               data.failure = value.at("failure");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           for (auto &cb : cbs_.failure_startup_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "log") {
           Log data;
           if (value.count("message") <= 0) {
               return {false, "missing_entry: message"};
           }
           try {
               data.message = value.at("message");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           if (value.count("log_level") <= 0) {
               return {false, "missing_entry: log_level"};
           }
           try {
               data.log_level = value.at("log_level");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           for (auto &cb : cbs_.log_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "measurement") {
           Measurement data;
           if (value.count("json_str") <= 0) {
               return {false, "missing_entry: json_str"};
           }
           try {
               data.json_str = value.at("json_str");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           if (value.count("idx") <= 0) {
               return {false, "missing_entry: idx"};
           }
           try {
               data.idx = value.at("idx");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           for (auto &cb : cbs_.measurement_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "status.end") {
           StatusEnd data;
           if (value.count("failure") <= 0) {
               return {false, "missing_entry: failure"};
           }
           try {
               data.failure = value.at("failure");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           if (value.count("uploaded_kb") <= 0) {
               return {false, "missing_entry: uploaded_kb"};
           }
           try {
               data.uploaded_kb = value.at("uploaded_kb");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           if (value.count("downloaded_kb") <= 0) {
               return {false, "missing_entry: downloaded_kb"};
           }
           try {
               data.downloaded_kb = value.at("downloaded_kb");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           for (auto &cb : cbs_.status_end_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "status.geoip_lookup") {
           StatusGeoipLookup data;
           if (value.count("probe_ip") <= 0) {
               return {false, "missing_entry: probe_ip"};
           }
           try {
               data.probe_ip = value.at("probe_ip");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           if (value.count("probe_network_name") <= 0) {
               return {false, "missing_entry: probe_network_name"};
           }
           try {
               data.probe_network_name = value.at("probe_network_name");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           if (value.count("probe_asn") <= 0) {
               return {false, "missing_entry: probe_asn"};
           }
           try {
               data.probe_asn = value.at("probe_asn");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           if (value.count("probe_cc") <= 0) {
               return {false, "missing_entry: probe_cc"};
           }
           try {
               data.probe_cc = value.at("probe_cc");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           for (auto &cb : cbs_.status_geoip_lookup_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "status.measurement_done") {
           StatusMeasurementDone data;
           if (value.count("idx") <= 0) {
               return {false, "missing_entry: idx"};
           }
           try {
               data.idx = value.at("idx");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           for (auto &cb : cbs_.status_measurement_done_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "status.measurement_start") {
           StatusMeasurementStart data;
           if (value.count("input") <= 0) {
               return {false, "missing_entry: input"};
           }
           try {
               data.input = value.at("input");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           if (value.count("idx") <= 0) {
               return {false, "missing_entry: idx"};
           }
           try {
               data.idx = value.at("idx");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           for (auto &cb : cbs_.status_measurement_start_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "status.measurement_submission") {
           StatusMeasurementSubmission data;
           if (value.count("idx") <= 0) {
               return {false, "missing_entry: idx"};
           }
           try {
               data.idx = value.at("idx");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           for (auto &cb : cbs_.status_measurement_submission_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "status.progress") {
           StatusProgress data;
           if (value.count("percentage") <= 0) {
               return {false, "missing_entry: percentage"};
           }
           try {
               data.percentage = value.at("percentage");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           if (value.count("message") <= 0) {
               return {false, "missing_entry: message"};
           }
           try {
               data.message = value.at("message");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           for (auto &cb : cbs_.status_progress_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "status.queued") {
           StatusQueued data;
           for (auto &cb : cbs_.status_queued_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "status.report_close") {
           StatusReportClose data;
           if (value.count("report_id") <= 0) {
               return {false, "missing_entry: report_id"};
           }
           try {
               data.report_id = value.at("report_id");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           for (auto &cb : cbs_.status_report_close_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "status.report_create") {
           StatusReportCreate data;
           if (value.count("report_id") <= 0) {
               return {false, "missing_entry: report_id"};
           }
           try {
               data.report_id = value.at("report_id");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           for (auto &cb : cbs_.status_report_create_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "status.resolver_lookup") {
           StatusResolverLookup data;
           if (value.count("resolver_ip") <= 0) {
               return {false, "missing_entry: resolver_ip"};
           }
           try {
               data.resolver_ip = value.at("resolver_ip");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           for (auto &cb : cbs_.status_resolver_lookup_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "status.started") {
           StatusStarted data;
           for (auto &cb : cbs_.status_started_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "status.terminated") {
           StatusTerminated data;
           for (auto &cb : cbs_.status_terminated_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "status.update.performance") {
           StatusUpdatePerformance data;
           if (value.count("direction") <= 0) {
               return {false, "missing_entry: direction"};
           }
           try {
               data.direction = value.at("direction");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           if (value.count("num_streams") <= 0) {
               return {false, "missing_entry: num_streams"};
           }
           try {
               data.num_streams = value.at("num_streams");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           if (value.count("speed_kbps") <= 0) {
               return {false, "missing_entry: speed_kbps"};
           }
           try {
               data.speed_kbps = value.at("speed_kbps");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           if (value.count("elapsed") <= 0) {
               return {false, "missing_entry: elapsed"};
           }
           try {
               data.elapsed = value.at("elapsed");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           for (auto &cb : cbs_.status_update_performance_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       if (key == "status.update.websites") {
           StatusUpdateWebsites data;
           if (value.count("url") <= 0) {
               return {false, "missing_entry: url"};
           }
           try {
               data.url = value.at("url");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           if (value.count("status") <= 0) {
               return {false, "missing_entry: status"};
           }
           try {
               data.status = value.at("status");
           } catch (const NlohmannJsonException &exc) {
               return {false, exc.what()};
           }
           for (auto &cb : cbs_.status_update_websites_cbs) {
               cb(data);
           }
           return {true, ""};
       }

       std::string reason = "unknown_key: ";
       reason += key;
       return {false, std::move(reason)};
    }

  private:
    EventsCallbacks cbs_;
};

} // namespace nettests
} // namespace mk
#endif // MEASUREMENT_KIT_NETTESTS_EVENTS_HPP
