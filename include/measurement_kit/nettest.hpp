// Part of Measurement Kit <https://measurement-kit.github.io/>.
// Measurement Kit is free software under the BSD license. See AUTHORS
// and LICENSE for more information on the copying conditions.
#ifndef MEASUREMENT_KIT_NETTEST_HPP
#define MEASUREMENT_KIT_NETTEST_HPP

/*-
 *  __      __  _____ __________  _______  .___ _______    ________
 * /  \    /  \/  _  \\______   \ \      \ |   |\      \  /  _____/
 * \   \/\/   /  /_\  \|       _/ /   |   \|   |/   |   \/   \  ___
 *  \        /    |    \    |   \/    |    \   /    |    \    \_\  \
 *   \__/\  /\____|__  /____|_  /\____|__  /___\____|__  /\______  /
 *        \/         \/       \/         \/            \/        \/
 *
 * Autogenerated by `./script/autoapi/autoapi`. DO NOT EDIT!!!
 */

/// \file include/measurement_kit/nettest.hpp
///
/// \brief C++11 API for running nettests.
///
/// This API is a C++11 adaptation of MK's FFI API. You should probably read
/// about such API first. \see https://github.com/measurement-kit/measurement-kit/blob/master/include/measurement_kit/README.md.
///
/// Usage is as follows:
///
/// ### 1. Instantiate settings
///
/// Create an instance of the settings of the nettest that you want to run
/// and set all the settings that you care about. You can pass around a
/// pointer or reference to the base class if you have common code written
/// to setup common options among different tests.
///
/// ```
/// extern void set_more_common_settings(mk::nettest::settings::CommonSettings *);
/// mk::nettest::settings::WhatsappSettings settings;
/// settings.all_endpoints = true;
/// settings.log_level = mk::nettest::log_levels::info;
/// set_more_common_settings(&settings);
/// ```
///
/// ### 2. Instatiate Nettest
///
/// Create an instance of the Nettest class. This class is non copyable
/// and non movable. If you want unique or shared ownership, you can
/// instantiate it either using `std::make_unique` or `std::make_shared`.
///
/// ```
/// mk::nettest::Nettest nettest;
/// ```
///
/// ### 3. Subclass Router
///
/// Create a subclass of Router suitable for routing the events that
/// the nettest will emit to overriden methods written by you. The default
/// behavior of the router is to ignore all events.
///
/// ```
/// class MyRouter : public mk::nettest::routers::Router {
///  public:
///   using mk::nettest::routers::Router::Router;
///
///   void on_log(const mk::nettest::event::LogEvent &event) override {
///     // Your event handling code here. Remember that this is called
///     // in the context of the FFI API's background thread.
///     //
///     // In this example we emit log messages on the standard error.
///     std::clog << event.log_level << ": " << event.message.
///   }
///
///  private:
///   // Your implementation variables here
/// }
/// ```
///
/// ### 4. Instantiate your router specialization
///
/// Create an instance of your router that will be used by this nettest. You
/// will later pass a pointer to this instance to methods emitting events.
///
/// ```
/// MyRouter my_router;
/// ```
///
/// ### 5. Start the Nettest
///
/// Start the nettest using the specific start method for the nettest
/// that you want to run. After this nettest specific method is called,
/// all the other methods are nettest-agnostic, so you can have a lot
/// of common nettest-processing code. Make sure you check the value
/// returned by the nettest-specific start method. In case of error log
/// messages will be emitted through the router.
///
/// ```
/// if (!nettest.start_whatsapp(&my_router)) {
///   // TODO: your code for handling this failure here.
///   return;
/// }
/// ```
///
/// ### 6. Dispatch nettest events
///
/// Dispatch nettest events. This is nettest-agnostic code. Calling the
/// Nettest::route_next_event() method will cause any pending events
/// to be extracted from the events queue and emitted through the router.
///
/// ```
/// while (!nettest.is_done()) {
///   nettest.route_next_event(&my_router);
/// }
/// ```
///
/// ### 7. Final remarks
///
/// If the nettest goes out of scope, it will not be interrupted, rather it
/// will run until completion without routing events. To interrupt a nettest,
/// use Nettest::interrupt(). When you need to share a Nettest instance
/// between different threads for the purpose of interrupting a test, your
/// best option is to use `new` or `std::make_shared`.
///
/// \see https://github.com/measurement-kit/measurement-kit/tree/master/example/nettest for usage examples.

#include <assert.h>
#include <stdint.h>

#include <deque>
#include <iostream>
#include <map>
#include <memory>
#include <mutex>
#include <sstream>
#include <string>
#include <thread>
#include <utility>
#include <vector>

#include <measurement_kit/common/nlohmann/json.hpp>
#include <measurement_kit/ffi.h>

/// Measurement Kit namespace.
namespace mk {

/// Namespace containing the nettest API.
namespace nettest {

/// Contains events definitions.
namespace events {

/// C++ representation of the "failure.asn_lookup" event.
class FailureAsnLookupEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "failure.asn_lookup";
    
    /// The "failure" attribute of this event.
    std::string failure = {};
};

/// C++ representation of the "failure.cc_lookup" event.
class FailureCcLookupEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "failure.cc_lookup";
    
    /// The "failure" attribute of this event.
    std::string failure = {};
};

/// C++ representation of the "failure.ip_lookup" event.
class FailureIpLookupEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "failure.ip_lookup";
    
    /// The "failure" attribute of this event.
    std::string failure = {};
};

/// C++ representation of the "failure.measurement" event.
class FailureMeasurementEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "failure.measurement";
    
    /// The "failure" attribute of this event.
    std::string failure = {};
};

/// C++ representation of the "failure.measurement_submission" event.
class FailureMeasurementSubmissionEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "failure.measurement_submission";
    
    /// The "failure" attribute of this event.
    std::string failure = {};
    
    /// The "idx" attribute of this event.
    int64_t idx = {};
    
    /// The "json_str" attribute of this event.
    std::string json_str = {};
};

/// C++ representation of the "failure.report_create" event.
class FailureReportCreateEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "failure.report_create";
    
    /// The "failure" attribute of this event.
    std::string failure = {};
};

/// C++ representation of the "failure.report_close" event.
class FailureReportCloseEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "failure.report_close";
    
    /// The "failure" attribute of this event.
    std::string failure = {};
};

/// C++ representation of the "failure.resolver_lookup" event.
class FailureResolverLookupEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "failure.resolver_lookup";
    
    /// The "failure" attribute of this event.
    std::string failure = {};
};

/// C++ representation of the "failure.startup" event.
class FailureStartupEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "failure.startup";
    
    /// The "failure" attribute of this event.
    std::string failure = {};
};

/// C++ representation of the "log" event.
class LogEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "log";
    
    /// The "log_level" attribute of this event.
    std::string log_level = {};
    
    /// The "message" attribute of this event.
    std::string message = {};
};

/// C++ representation of the "measurement" event.
class MeasurementEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "measurement";
    
    /// The "idx" attribute of this event.
    int64_t idx = {};
    
    /// The "json_str" attribute of this event.
    std::string json_str = {};
};

/// C++ representation of the "status.end" event.
class StatusEndEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.end";
    
    /// The "downloaded_kb" attribute of this event.
    double downloaded_kb = {};
    
    /// The "uploaded_kb" attribute of this event.
    double uploaded_kb = {};
    
    /// The "failure" attribute of this event.
    std::string failure = {};
};

/// C++ representation of the "status.geoip_lookup" event.
class StatusGeoipLookupEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.geoip_lookup";
    
    /// The "probe_ip" attribute of this event.
    std::string probe_ip = {};
    
    /// The "probe_asn" attribute of this event.
    std::string probe_asn = {};
    
    /// The "probe_cc" attribute of this event.
    std::string probe_cc = {};
    
    /// The "probe_network_name" attribute of this event.
    std::string probe_network_name = {};
};

/// C++ representation of the "status.progress" event.
class StatusProgressEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.progress";
    
    /// The "percentage" attribute of this event.
    double percentage = {};
    
    /// The "message" attribute of this event.
    std::string message = {};
};

/// C++ representation of the "status.queued" event.
class StatusQueuedEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.queued";
    /* No attributes */
};

/// C++ representation of the "status.measurement_start" event.
class StatusMeasurementStartEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.measurement_start";
    
    /// The "idx" attribute of this event.
    int64_t idx = {};
    
    /// The "input" attribute of this event.
    std::string input = {};
};

/// C++ representation of the "status.measurement_submission" event.
class StatusMeasurementSubmissionEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.measurement_submission";
    
    /// The "idx" attribute of this event.
    int64_t idx = {};
};

/// C++ representation of the "status.measurement_done" event.
class StatusMeasurementDoneEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.measurement_done";
    
    /// The "idx" attribute of this event.
    int64_t idx = {};
};

/// C++ representation of the "status.report_close" event.
class StatusReportCloseEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.report_close";
    
    /// The "report_id" attribute of this event.
    std::string report_id = {};
};

/// C++ representation of the "status.report_create" event.
class StatusReportCreateEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.report_create";
    
    /// The "report_id" attribute of this event.
    std::string report_id = {};
};

/// C++ representation of the "status.resolver_lookup" event.
class StatusResolverLookupEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.resolver_lookup";
    
    /// The "ip_address" attribute of this event.
    std::string ip_address = {};
};

/// C++ representation of the "status.started" event.
class StatusStartedEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.started";
    /* No attributes */
};

/// C++ representation of the "status.update.performance" event.
class StatusUpdatePerformanceEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.update.performance";
    
    /// The "direction" attribute of this event.
    std::string direction = {};
    
    /// The "elapsed" attribute of this event.
    double elapsed = {};
    
    /// The "num_streams" attribute of this event.
    int64_t num_streams = {};
    
    /// The "speed_kbps" attribute of this event.
    double speed_kbps = {};
};

/// C++ representation of the "status.update.websites" event.
class StatusUpdateWebsitesEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.update.websites";
    
    /// The "url" attribute of this event.
    std::string url = {};
    
    /// The "status" attribute of this event.
    std::string status = {};
};

/// C++ representation of the "task_terminated" event.
class TaskTerminatedEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "task_terminated";
    /* No attributes */
};

} // namespace events

/// Contains log levels constants.
namespace log_levels {
/// String representation of the "err" log level.
constexpr const char *err = "ERR";

    /// String representation of the "warning" log level.
constexpr const char *warning = "WARNING";

    /// String representation of the "info" log level.
constexpr const char *info = "INFO";

    /// String representation of the "debug" log level.
constexpr const char *debug = "DEBUG";

    /// String representation of the "debug2" log level.
constexpr const char *debug2 = "DEBUG2";
} // namespace log levels

/// Contains settings classes.
namespace settings {

/// Settings common to all nettests.
class CommonSettings {
  public:
    /// The "annotations" setting.
    std::map<std::string, std::string> annotations = {};

    /// The "disabled_events" setting.
    std::vector<std::string> disabled_events = {};

    /// The "inputs" setting.
    std::vector<std::string> inputs = {};

    /// The "input_filepaths" setting.
    std::vector<std::string> input_filepaths = {};

    /// The "log_filepath" setting.
    std::string log_filepath = {};

    /// The "log_level" setting.
    std::string log_level = log_levels::err;

    /// The "output_filepath" setting.
    std::string output_filepath = {};

    /// The "bouncer_base_url" setting.
    std::string bouncer_base_url = "https://bouncer.ooni.io";

    /// The "collector_base_url" setting.
    std::string collector_base_url = {};

    /// The "dns/nameserver" setting.
    std::string dns_nameserver = {};

    /// The "dns/engine" setting.
    std::string dns_engine = "system";

    /// The "geoip_asn_path" setting.
    std::string geoip_asn_path = {};

    /// The "geoip_country_path" setting.
    std::string geoip_country_path = {};

    /// The "ignore_bouncer_error" setting.
    bool ignore_bouncer_error = true;

    /// The "ignore_open_report_error" setting.
    bool ignore_open_report_error = true;

    /// The "max_runtime" setting.
    double max_runtime = -1.0;

    /// The "net/ca_bundle_path" setting.
    std::string net_ca_bundle_path = {};

    /// The "net/timeout" setting.
    double net_timeout = 10.0;

    /// The "no_bouncer" setting.
    bool no_bouncer = false;

    /// The "no_collector" setting.
    bool no_collector = false;

    /// The "no_asn_lookup" setting.
    bool no_asn_lookup = false;

    /// The "no_cc_lookup" setting.
    bool no_cc_lookup = false;

    /// The "no_ip_lookup" setting.
    bool no_ip_lookup = false;

    /// The "no_file_report" setting.
    bool no_file_report = false;

    /// The "no_resolver_lookup" setting.
    bool no_resolver_lookup = false;

    /// The "probe_asn" setting.
    std::string probe_asn = {};

    /// The "probe_cc" setting.
    std::string probe_cc = {};

    /// The "probe_ip" setting.
    std::string probe_ip = {};

    /// The "randomize_input" setting.
    bool randomize_input = true;

    /// The "save_real_probe_asn" setting.
    bool save_real_probe_asn = true;

    /// The "save_real_probe_cc" setting.
    bool save_real_probe_cc = true;

    /// The "save_real_probe_ip" setting.
    bool save_real_probe_ip = false;

    /// The "save_real_resolver_ip" setting.
    bool save_real_resolver_ip = true;

    /// The "software_name" setting.
    std::string software_name = {};

    /// The "software_version" setting.
    std::string software_version = {};
};

/// Settings of the "CaptivePortal" nettest.
class CaptivePortalSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "CaptivePortal";
    /* No nettest-specific settings */
};

/// Settings of the "Dash" nettest.
class DashSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "Dash";
    /* No nettest-specific settings */
};

/// Settings of the "DnsInjection" nettest.
class DnsInjectionSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "DnsInjection";
    /* No nettest-specific settings */
};

/// Settings of the "FacebookMessenger" nettest.
class FacebookMessengerSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "FacebookMessenger";
    /* No nettest-specific settings */
};

/// Settings of the "HttpHeaderFieldManipulation" nettest.
class HttpHeaderFieldManipulationSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "HttpHeaderFieldManipulation";
    /* No nettest-specific settings */
};

/// Settings of the "HttpInvalidRequestLine" nettest.
class HttpInvalidRequestLineSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "HttpInvalidRequestLine";
    /* No nettest-specific settings */
};

/// Settings of the "MeekFrontedRequests" nettest.
class MeekFrontedRequestsSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "MeekFrontedRequests";
    /* No nettest-specific settings */
};

/// Settings of the "MultiNdt" nettest.
class MultiNdtSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "MultiNdt";
    /* No nettest-specific settings */
};

/// Settings of the "Ndt" nettest.
class NdtSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "Ndt";
    /* No nettest-specific settings */
};

/// Settings of the "TcpConnect" nettest.
class TcpConnectSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "TcpConnect";
    /* No nettest-specific settings */
};

/// Settings of the "Telegram" nettest.
class TelegramSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "Telegram";
    /* No nettest-specific settings */
};

/// Settings of the "WebConnectivity" nettest.
class WebConnectivitySettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "WebConnectivity";
    /* No nettest-specific settings */
};

/// Settings of the "Whatsapp" nettest.
class WhatsappSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "Whatsapp";
    
    /// The "all_endpoints" setting of this nettest.
    bool all_endpoints = false;
};

} // namespace settings

// Contains the routers
namespace routers {

/// Routes nettest events to virtual methods.
class Router {
  public:
    // Implementation note: virtual methods cannot be `noexcept` because the
    // task stable version of SWIG does not handle that correctly.

    /// Handles the "failure.asn_lookup" event.
    virtual void on_failure_asn_lookup(const events::FailureAsnLookupEvent &event);

    /// Handles the "failure.cc_lookup" event.
    virtual void on_failure_cc_lookup(const events::FailureCcLookupEvent &event);

    /// Handles the "failure.ip_lookup" event.
    virtual void on_failure_ip_lookup(const events::FailureIpLookupEvent &event);

    /// Handles the "failure.measurement" event.
    virtual void on_failure_measurement(const events::FailureMeasurementEvent &event);

    /// Handles the "failure.measurement_submission" event.
    virtual void on_failure_measurement_submission(const events::FailureMeasurementSubmissionEvent &event);

    /// Handles the "failure.report_create" event.
    virtual void on_failure_report_create(const events::FailureReportCreateEvent &event);

    /// Handles the "failure.report_close" event.
    virtual void on_failure_report_close(const events::FailureReportCloseEvent &event);

    /// Handles the "failure.resolver_lookup" event.
    virtual void on_failure_resolver_lookup(const events::FailureResolverLookupEvent &event);

    /// Handles the "failure.startup" event.
    virtual void on_failure_startup(const events::FailureStartupEvent &event);

    /// Handles the "log" event.
    virtual void on_log(const events::LogEvent &event);

    /// Handles the "measurement" event.
    virtual void on_measurement(const events::MeasurementEvent &event);

    /// Handles the "status.end" event.
    virtual void on_status_end(const events::StatusEndEvent &event);

    /// Handles the "status.geoip_lookup" event.
    virtual void on_status_geoip_lookup(const events::StatusGeoipLookupEvent &event);

    /// Handles the "status.progress" event.
    virtual void on_status_progress(const events::StatusProgressEvent &event);

    /// Handles the "status.queued" event.
    virtual void on_status_queued(const events::StatusQueuedEvent &event);

    /// Handles the "status.measurement_start" event.
    virtual void on_status_measurement_start(const events::StatusMeasurementStartEvent &event);

    /// Handles the "status.measurement_submission" event.
    virtual void on_status_measurement_submission(const events::StatusMeasurementSubmissionEvent &event);

    /// Handles the "status.measurement_done" event.
    virtual void on_status_measurement_done(const events::StatusMeasurementDoneEvent &event);

    /// Handles the "status.report_close" event.
    virtual void on_status_report_close(const events::StatusReportCloseEvent &event);

    /// Handles the "status.report_create" event.
    virtual void on_status_report_create(const events::StatusReportCreateEvent &event);

    /// Handles the "status.resolver_lookup" event.
    virtual void on_status_resolver_lookup(const events::StatusResolverLookupEvent &event);

    /// Handles the "status.started" event.
    virtual void on_status_started(const events::StatusStartedEvent &event);

    /// Handles the "status.update.performance" event.
    virtual void on_status_update_performance(const events::StatusUpdatePerformanceEvent &event);

    /// Handles the "status.update.websites" event.
    virtual void on_status_update_websites(const events::StatusUpdateWebsitesEvent &event);

    /// Handles the "task_terminated" event.
    virtual void on_task_terminated(const events::TaskTerminatedEvent &event);

    virtual ~Router() noexcept;
};

/// Router that logs everything on std::clog.
class NoisyRouter : public Router {
  public:
    /// Logs the "failure.asn_lookup" event on std::clog.
    void on_failure_asn_lookup(const events::FailureAsnLookupEvent &event) override;

    /// Logs the "failure.cc_lookup" event on std::clog.
    void on_failure_cc_lookup(const events::FailureCcLookupEvent &event) override;

    /// Logs the "failure.ip_lookup" event on std::clog.
    void on_failure_ip_lookup(const events::FailureIpLookupEvent &event) override;

    /// Logs the "failure.measurement" event on std::clog.
    void on_failure_measurement(const events::FailureMeasurementEvent &event) override;

    /// Logs the "failure.measurement_submission" event on std::clog.
    void on_failure_measurement_submission(const events::FailureMeasurementSubmissionEvent &event) override;

    /// Logs the "failure.report_create" event on std::clog.
    void on_failure_report_create(const events::FailureReportCreateEvent &event) override;

    /// Logs the "failure.report_close" event on std::clog.
    void on_failure_report_close(const events::FailureReportCloseEvent &event) override;

    /// Logs the "failure.resolver_lookup" event on std::clog.
    void on_failure_resolver_lookup(const events::FailureResolverLookupEvent &event) override;

    /// Logs the "failure.startup" event on std::clog.
    void on_failure_startup(const events::FailureStartupEvent &event) override;

    /// Logs the "log" event on std::clog.
    void on_log(const events::LogEvent &event) override;

    /// Logs the "measurement" event on std::clog.
    void on_measurement(const events::MeasurementEvent &event) override;

    /// Logs the "status.end" event on std::clog.
    void on_status_end(const events::StatusEndEvent &event) override;

    /// Logs the "status.geoip_lookup" event on std::clog.
    void on_status_geoip_lookup(const events::StatusGeoipLookupEvent &event) override;

    /// Logs the "status.progress" event on std::clog.
    void on_status_progress(const events::StatusProgressEvent &event) override;

    /// Logs the "status.queued" event on std::clog.
    void on_status_queued(const events::StatusQueuedEvent &event) override;

    /// Logs the "status.measurement_start" event on std::clog.
    void on_status_measurement_start(const events::StatusMeasurementStartEvent &event) override;

    /// Logs the "status.measurement_submission" event on std::clog.
    void on_status_measurement_submission(const events::StatusMeasurementSubmissionEvent &event) override;

    /// Logs the "status.measurement_done" event on std::clog.
    void on_status_measurement_done(const events::StatusMeasurementDoneEvent &event) override;

    /// Logs the "status.report_close" event on std::clog.
    void on_status_report_close(const events::StatusReportCloseEvent &event) override;

    /// Logs the "status.report_create" event on std::clog.
    void on_status_report_create(const events::StatusReportCreateEvent &event) override;

    /// Logs the "status.resolver_lookup" event on std::clog.
    void on_status_resolver_lookup(const events::StatusResolverLookupEvent &event) override;

    /// Logs the "status.started" event on std::clog.
    void on_status_started(const events::StatusStartedEvent &event) override;

    /// Logs the "status.update.performance" event on std::clog.
    void on_status_update_performance(const events::StatusUpdatePerformanceEvent &event) override;

    /// Logs the "status.update.websites" event on std::clog.
    void on_status_update_websites(const events::StatusUpdateWebsitesEvent &event) override;

    /// Logs the "task_terminated" event on std::clog.
    void on_task_terminated(const events::TaskTerminatedEvent &event) override;

    ~NoisyRouter() noexcept override;
};

} // namespace routers

/// Manages the lifecycle of a nettest. This API mirrors as closely as
/// possible to FFI API provided by <measurement_kit/ffi.h>.
class Nettest {
  public:
    // C++ object model
    // ````````````````

    /// Creates a nettest instance. This will not start the actual test. You
    /// need to use one of the start_XXX() methods to do that.
    Nettest() noexcept;

    /// Explicitly deleted copy constructor.
    Nettest(const Nettest &) noexcept = delete;

    /// Explicitly deleted copy assignment.
    Nettest &operator=(const Nettest &) noexcept = delete;

    /// Explicitly deleted move constructor.
    Nettest(Nettest &&) noexcept = delete;

    /// Explicitly deleted move assignment.
    Nettest &operator=(Nettest &&) noexcept = delete;

    /// Wait for nettest to terminate and destroy resources.
    ~Nettest() noexcept;

    // Starting a nettest
    // ``````````````````

    /// Starts a "CaptivePortal" nettest.
    /// \param settings contains the settings configuring this nettest.
    /// \param router is the router used to route nettest events. If the
    /// router is `nullptr`, we'll use an internal dummy router.
    /// \return true on success, false on failure. There are two reasons why
    /// this method could fail. Either the provided settings are not JSON
    /// serializable because there was a string that was not valid UTF-8, or
    /// you already used this class to start a nettest. In both cases, log
    /// messages will be routed, so you will know what happened.
    bool start_captive_portal(settings::CaptivePortalSettings settings, routers::Router *router) noexcept;

    /// Starts a "Dash" nettest.
    /// \param settings contains the settings configuring this nettest.
    /// \param router is the router used to route nettest events. If the
    /// router is `nullptr`, we'll use an internal dummy router.
    /// \return true on success, false on failure. There are two reasons why
    /// this method could fail. Either the provided settings are not JSON
    /// serializable because there was a string that was not valid UTF-8, or
    /// you already used this class to start a nettest. In both cases, log
    /// messages will be routed, so you will know what happened.
    bool start_dash(settings::DashSettings settings, routers::Router *router) noexcept;

    /// Starts a "DnsInjection" nettest.
    /// \param settings contains the settings configuring this nettest.
    /// \param router is the router used to route nettest events. If the
    /// router is `nullptr`, we'll use an internal dummy router.
    /// \return true on success, false on failure. There are two reasons why
    /// this method could fail. Either the provided settings are not JSON
    /// serializable because there was a string that was not valid UTF-8, or
    /// you already used this class to start a nettest. In both cases, log
    /// messages will be routed, so you will know what happened.
    bool start_dns_injection(settings::DnsInjectionSettings settings, routers::Router *router) noexcept;

    /// Starts a "FacebookMessenger" nettest.
    /// \param settings contains the settings configuring this nettest.
    /// \param router is the router used to route nettest events. If the
    /// router is `nullptr`, we'll use an internal dummy router.
    /// \return true on success, false on failure. There are two reasons why
    /// this method could fail. Either the provided settings are not JSON
    /// serializable because there was a string that was not valid UTF-8, or
    /// you already used this class to start a nettest. In both cases, log
    /// messages will be routed, so you will know what happened.
    bool start_facebook_messenger(settings::FacebookMessengerSettings settings, routers::Router *router) noexcept;

    /// Starts a "HttpHeaderFieldManipulation" nettest.
    /// \param settings contains the settings configuring this nettest.
    /// \param router is the router used to route nettest events. If the
    /// router is `nullptr`, we'll use an internal dummy router.
    /// \return true on success, false on failure. There are two reasons why
    /// this method could fail. Either the provided settings are not JSON
    /// serializable because there was a string that was not valid UTF-8, or
    /// you already used this class to start a nettest. In both cases, log
    /// messages will be routed, so you will know what happened.
    bool start_http_header_field_manipulation(settings::HttpHeaderFieldManipulationSettings settings, routers::Router *router) noexcept;

    /// Starts a "HttpInvalidRequestLine" nettest.
    /// \param settings contains the settings configuring this nettest.
    /// \param router is the router used to route nettest events. If the
    /// router is `nullptr`, we'll use an internal dummy router.
    /// \return true on success, false on failure. There are two reasons why
    /// this method could fail. Either the provided settings are not JSON
    /// serializable because there was a string that was not valid UTF-8, or
    /// you already used this class to start a nettest. In both cases, log
    /// messages will be routed, so you will know what happened.
    bool start_http_invalid_request_line(settings::HttpInvalidRequestLineSettings settings, routers::Router *router) noexcept;

    /// Starts a "MeekFrontedRequests" nettest.
    /// \param settings contains the settings configuring this nettest.
    /// \param router is the router used to route nettest events. If the
    /// router is `nullptr`, we'll use an internal dummy router.
    /// \return true on success, false on failure. There are two reasons why
    /// this method could fail. Either the provided settings are not JSON
    /// serializable because there was a string that was not valid UTF-8, or
    /// you already used this class to start a nettest. In both cases, log
    /// messages will be routed, so you will know what happened.
    bool start_meek_fronted_requests(settings::MeekFrontedRequestsSettings settings, routers::Router *router) noexcept;

    /// Starts a "MultiNdt" nettest.
    /// \param settings contains the settings configuring this nettest.
    /// \param router is the router used to route nettest events. If the
    /// router is `nullptr`, we'll use an internal dummy router.
    /// \return true on success, false on failure. There are two reasons why
    /// this method could fail. Either the provided settings are not JSON
    /// serializable because there was a string that was not valid UTF-8, or
    /// you already used this class to start a nettest. In both cases, log
    /// messages will be routed, so you will know what happened.
    bool start_multi_ndt(settings::MultiNdtSettings settings, routers::Router *router) noexcept;

    /// Starts a "Ndt" nettest.
    /// \param settings contains the settings configuring this nettest.
    /// \param router is the router used to route nettest events. If the
    /// router is `nullptr`, we'll use an internal dummy router.
    /// \return true on success, false on failure. There are two reasons why
    /// this method could fail. Either the provided settings are not JSON
    /// serializable because there was a string that was not valid UTF-8, or
    /// you already used this class to start a nettest. In both cases, log
    /// messages will be routed, so you will know what happened.
    bool start_ndt(settings::NdtSettings settings, routers::Router *router) noexcept;

    /// Starts a "TcpConnect" nettest.
    /// \param settings contains the settings configuring this nettest.
    /// \param router is the router used to route nettest events. If the
    /// router is `nullptr`, we'll use an internal dummy router.
    /// \return true on success, false on failure. There are two reasons why
    /// this method could fail. Either the provided settings are not JSON
    /// serializable because there was a string that was not valid UTF-8, or
    /// you already used this class to start a nettest. In both cases, log
    /// messages will be routed, so you will know what happened.
    bool start_tcp_connect(settings::TcpConnectSettings settings, routers::Router *router) noexcept;

    /// Starts a "Telegram" nettest.
    /// \param settings contains the settings configuring this nettest.
    /// \param router is the router used to route nettest events. If the
    /// router is `nullptr`, we'll use an internal dummy router.
    /// \return true on success, false on failure. There are two reasons why
    /// this method could fail. Either the provided settings are not JSON
    /// serializable because there was a string that was not valid UTF-8, or
    /// you already used this class to start a nettest. In both cases, log
    /// messages will be routed, so you will know what happened.
    bool start_telegram(settings::TelegramSettings settings, routers::Router *router) noexcept;

    /// Starts a "WebConnectivity" nettest.
    /// \param settings contains the settings configuring this nettest.
    /// \param router is the router used to route nettest events. If the
    /// router is `nullptr`, we'll use an internal dummy router.
    /// \return true on success, false on failure. There are two reasons why
    /// this method could fail. Either the provided settings are not JSON
    /// serializable because there was a string that was not valid UTF-8, or
    /// you already used this class to start a nettest. In both cases, log
    /// messages will be routed, so you will know what happened.
    bool start_web_connectivity(settings::WebConnectivitySettings settings, routers::Router *router) noexcept;

    /// Starts a "Whatsapp" nettest.
    /// \param settings contains the settings configuring this nettest.
    /// \param router is the router used to route nettest events. If the
    /// router is `nullptr`, we'll use an internal dummy router.
    /// \return true on success, false on failure. There are two reasons why
    /// this method could fail. Either the provided settings are not JSON
    /// serializable because there was a string that was not valid UTF-8, or
    /// you already used this class to start a nettest. In both cases, log
    /// messages will be routed, so you will know what happened.
    bool start_whatsapp(settings::WhatsappSettings settings, routers::Router *router) noexcept;

    // Event processing methods
    // ````````````````````````

    /// Blocks until the next event occurs, then routes it.
    /// \param router Router to handle events. If the router is null, we'll
    /// use an internal dummy router.
    void route_next_event(routers::Router *router) noexcept;

    /// Returns true if nettest is done, false otherwise.
    bool is_done() noexcept;

    /// Interrupts the currently running nettest.
    void interrupt() noexcept;

  private:
    // Private methods
    // ```````````````

    // The default router used when no other router is available.
    static routers::Router *default_router() noexcept;

    // Internal method called to start any nettest.
    bool start_common(nlohmann::json, const settings::CommonSettings &, routers::Router *router) noexcept;

    // Private definitions
    // ```````````````````

    // Deleter for mk_task_t.
    class TaskDeleter {
      public:
        void operator()(mk_task_t *task) noexcept { mk_task_destroy(task); }
    };

    // Syntactic sugar of a unique mk_task_t pointer.
    using UniqueTask = std::unique_ptr<mk_task_t, TaskDeleter>;

    // Deleter for mk_event_t.
    class EventDeleter {
      public:
        void operator()(mk_event_t *event) noexcept { mk_event_destroy(event); }
    };

    // Syntactic sugar for a unique mk_event_t pointer.
    using UniqueEvent = std::unique_ptr<mk_event_t, EventDeleter>;

    // Private attributes
    // ``````````````````

    // Mutex used to protect the task_ attribute.
    std::mutex mutex_;

    // Unique pointer to the FFI task.
    UniqueTask task_;
};

/*-
 * __________        .__               __
 * \______   \_______|__|__  _______ _/  |_  ____
 *  |     ___/\_  __ \  \  \/ /\__  \\   __\/ __ \
 *  |    |     |  | \/  |\   /  / __ \|  | \  ___/
 *  |____|     |__|  |__| \_/  (____  /__|  \___  >
 *                                  \/          \/
 *
 * Definitions ends here. What follows is the inline implementation of this
 * API, which you can exclude by setting MK_NETTEST_NO_INLINE_IMPL.
 *
 * This is handy if you want to include this code in many translation
 * units to include the implementation into a single object.
 */
#if !defined MK_NETTEST_NO_INLINE_IMPL && !defined SWIG

// Routers
// -------

namespace routers {

void Router::on_failure_asn_lookup(const events::FailureAsnLookupEvent &) {}

void Router::on_failure_cc_lookup(const events::FailureCcLookupEvent &) {}

void Router::on_failure_ip_lookup(const events::FailureIpLookupEvent &) {}

void Router::on_failure_measurement(const events::FailureMeasurementEvent &) {}

void Router::on_failure_measurement_submission(const events::FailureMeasurementSubmissionEvent &) {}

void Router::on_failure_report_create(const events::FailureReportCreateEvent &) {}

void Router::on_failure_report_close(const events::FailureReportCloseEvent &) {}

void Router::on_failure_resolver_lookup(const events::FailureResolverLookupEvent &) {}

void Router::on_failure_startup(const events::FailureStartupEvent &) {}

void Router::on_log(const events::LogEvent &) {}

void Router::on_measurement(const events::MeasurementEvent &) {}

void Router::on_status_end(const events::StatusEndEvent &) {}

void Router::on_status_geoip_lookup(const events::StatusGeoipLookupEvent &) {}

void Router::on_status_progress(const events::StatusProgressEvent &) {}

void Router::on_status_queued(const events::StatusQueuedEvent &) {}

void Router::on_status_measurement_start(const events::StatusMeasurementStartEvent &) {}

void Router::on_status_measurement_submission(const events::StatusMeasurementSubmissionEvent &) {}

void Router::on_status_measurement_done(const events::StatusMeasurementDoneEvent &) {}

void Router::on_status_report_close(const events::StatusReportCloseEvent &) {}

void Router::on_status_report_create(const events::StatusReportCreateEvent &) {}

void Router::on_status_resolver_lookup(const events::StatusResolverLookupEvent &) {}

void Router::on_status_started(const events::StatusStartedEvent &) {}

void Router::on_status_update_performance(const events::StatusUpdatePerformanceEvent &) {}

void Router::on_status_update_websites(const events::StatusUpdateWebsitesEvent &) {}

void Router::on_task_terminated(const events::TaskTerminatedEvent &) {}

Router::~Router() noexcept {}

void NoisyRouter::on_failure_asn_lookup(const events::FailureAsnLookupEvent &event) {
    std::clog << "failure.asn_lookup";
    std::clog << ":";
    std::clog << " failure='" << event.failure << "'";
    std::clog << std::endl;
}

void NoisyRouter::on_failure_cc_lookup(const events::FailureCcLookupEvent &event) {
    std::clog << "failure.cc_lookup";
    std::clog << ":";
    std::clog << " failure='" << event.failure << "'";
    std::clog << std::endl;
}

void NoisyRouter::on_failure_ip_lookup(const events::FailureIpLookupEvent &event) {
    std::clog << "failure.ip_lookup";
    std::clog << ":";
    std::clog << " failure='" << event.failure << "'";
    std::clog << std::endl;
}

void NoisyRouter::on_failure_measurement(const events::FailureMeasurementEvent &event) {
    std::clog << "failure.measurement";
    std::clog << ":";
    std::clog << " failure='" << event.failure << "'";
    std::clog << std::endl;
}

void NoisyRouter::on_failure_measurement_submission(const events::FailureMeasurementSubmissionEvent &event) {
    std::clog << "failure.measurement_submission";
    std::clog << ":";
    std::clog << " failure='" << event.failure << "'";
    std::clog << " idx='" << event.idx << "'";
    std::clog << " json_str='" << event.json_str << "'";
    std::clog << std::endl;
}

void NoisyRouter::on_failure_report_create(const events::FailureReportCreateEvent &event) {
    std::clog << "failure.report_create";
    std::clog << ":";
    std::clog << " failure='" << event.failure << "'";
    std::clog << std::endl;
}

void NoisyRouter::on_failure_report_close(const events::FailureReportCloseEvent &event) {
    std::clog << "failure.report_close";
    std::clog << ":";
    std::clog << " failure='" << event.failure << "'";
    std::clog << std::endl;
}

void NoisyRouter::on_failure_resolver_lookup(const events::FailureResolverLookupEvent &event) {
    std::clog << "failure.resolver_lookup";
    std::clog << ":";
    std::clog << " failure='" << event.failure << "'";
    std::clog << std::endl;
}

void NoisyRouter::on_failure_startup(const events::FailureStartupEvent &event) {
    std::clog << "failure.startup";
    std::clog << ":";
    std::clog << " failure='" << event.failure << "'";
    std::clog << std::endl;
}

void NoisyRouter::on_log(const events::LogEvent &event) {
    std::clog << "log";
    std::clog << ":";
    std::clog << " log_level='" << event.log_level << "'";
    std::clog << " message='" << event.message << "'";
    std::clog << std::endl;
}

void NoisyRouter::on_measurement(const events::MeasurementEvent &event) {
    std::clog << "measurement";
    std::clog << ":";
    std::clog << " idx='" << event.idx << "'";
    std::clog << " json_str='" << event.json_str << "'";
    std::clog << std::endl;
}

void NoisyRouter::on_status_end(const events::StatusEndEvent &event) {
    std::clog << "status.end";
    std::clog << ":";
    std::clog << " downloaded_kb='" << event.downloaded_kb << "'";
    std::clog << " uploaded_kb='" << event.uploaded_kb << "'";
    std::clog << " failure='" << event.failure << "'";
    std::clog << std::endl;
}

void NoisyRouter::on_status_geoip_lookup(const events::StatusGeoipLookupEvent &event) {
    std::clog << "status.geoip_lookup";
    std::clog << ":";
    std::clog << " probe_ip='" << event.probe_ip << "'";
    std::clog << " probe_asn='" << event.probe_asn << "'";
    std::clog << " probe_cc='" << event.probe_cc << "'";
    std::clog << " probe_network_name='" << event.probe_network_name << "'";
    std::clog << std::endl;
}

void NoisyRouter::on_status_progress(const events::StatusProgressEvent &event) {
    std::clog << "status.progress";
    std::clog << ":";
    std::clog << " percentage='" << event.percentage << "'";
    std::clog << " message='" << event.message << "'";
    std::clog << std::endl;
}

void NoisyRouter::on_status_queued(const events::StatusQueuedEvent &event) {
    std::clog << "status.queued";
    (void)event; /* No event attributes */
    std::clog << std::endl;
}

void NoisyRouter::on_status_measurement_start(const events::StatusMeasurementStartEvent &event) {
    std::clog << "status.measurement_start";
    std::clog << ":";
    std::clog << " idx='" << event.idx << "'";
    std::clog << " input='" << event.input << "'";
    std::clog << std::endl;
}

void NoisyRouter::on_status_measurement_submission(const events::StatusMeasurementSubmissionEvent &event) {
    std::clog << "status.measurement_submission";
    std::clog << ":";
    std::clog << " idx='" << event.idx << "'";
    std::clog << std::endl;
}

void NoisyRouter::on_status_measurement_done(const events::StatusMeasurementDoneEvent &event) {
    std::clog << "status.measurement_done";
    std::clog << ":";
    std::clog << " idx='" << event.idx << "'";
    std::clog << std::endl;
}

void NoisyRouter::on_status_report_close(const events::StatusReportCloseEvent &event) {
    std::clog << "status.report_close";
    std::clog << ":";
    std::clog << " report_id='" << event.report_id << "'";
    std::clog << std::endl;
}

void NoisyRouter::on_status_report_create(const events::StatusReportCreateEvent &event) {
    std::clog << "status.report_create";
    std::clog << ":";
    std::clog << " report_id='" << event.report_id << "'";
    std::clog << std::endl;
}

void NoisyRouter::on_status_resolver_lookup(const events::StatusResolverLookupEvent &event) {
    std::clog << "status.resolver_lookup";
    std::clog << ":";
    std::clog << " ip_address='" << event.ip_address << "'";
    std::clog << std::endl;
}

void NoisyRouter::on_status_started(const events::StatusStartedEvent &event) {
    std::clog << "status.started";
    (void)event; /* No event attributes */
    std::clog << std::endl;
}

void NoisyRouter::on_status_update_performance(const events::StatusUpdatePerformanceEvent &event) {
    std::clog << "status.update.performance";
    std::clog << ":";
    std::clog << " direction='" << event.direction << "'";
    std::clog << " elapsed='" << event.elapsed << "'";
    std::clog << " num_streams='" << event.num_streams << "'";
    std::clog << " speed_kbps='" << event.speed_kbps << "'";
    std::clog << std::endl;
}

void NoisyRouter::on_status_update_websites(const events::StatusUpdateWebsitesEvent &event) {
    std::clog << "status.update.websites";
    std::clog << ":";
    std::clog << " url='" << event.url << "'";
    std::clog << " status='" << event.status << "'";
    std::clog << std::endl;
}

void NoisyRouter::on_task_terminated(const events::TaskTerminatedEvent &event) {
    std::clog << "task_terminated";
    (void)event; /* No event attributes */
    std::clog << std::endl;
}

NoisyRouter::~NoisyRouter() noexcept {}

} // namespace routers

// Nettest
// -------

Nettest::Nettest() noexcept {}

Nettest::~Nettest() noexcept {}

bool Nettest::start_captive_portal(settings::CaptivePortalSettings settings, routers::Router *router) noexcept {
    router = (router) ? router : default_router();
    nlohmann::json doc;
    doc["name"] = "CaptivePortal";
    /* No nettest specific settings */
    return start_common(std::move(doc), settings, router);
}

bool Nettest::start_dash(settings::DashSettings settings, routers::Router *router) noexcept {
    router = (router) ? router : default_router();
    nlohmann::json doc;
    doc["name"] = "Dash";
    /* No nettest specific settings */
    return start_common(std::move(doc), settings, router);
}

bool Nettest::start_dns_injection(settings::DnsInjectionSettings settings, routers::Router *router) noexcept {
    router = (router) ? router : default_router();
    nlohmann::json doc;
    doc["name"] = "DnsInjection";
    /* No nettest specific settings */
    return start_common(std::move(doc), settings, router);
}

bool Nettest::start_facebook_messenger(settings::FacebookMessengerSettings settings, routers::Router *router) noexcept {
    router = (router) ? router : default_router();
    nlohmann::json doc;
    doc["name"] = "FacebookMessenger";
    /* No nettest specific settings */
    return start_common(std::move(doc), settings, router);
}

bool Nettest::start_http_header_field_manipulation(settings::HttpHeaderFieldManipulationSettings settings, routers::Router *router) noexcept {
    router = (router) ? router : default_router();
    nlohmann::json doc;
    doc["name"] = "HttpHeaderFieldManipulation";
    /* No nettest specific settings */
    return start_common(std::move(doc), settings, router);
}

bool Nettest::start_http_invalid_request_line(settings::HttpInvalidRequestLineSettings settings, routers::Router *router) noexcept {
    router = (router) ? router : default_router();
    nlohmann::json doc;
    doc["name"] = "HttpInvalidRequestLine";
    /* No nettest specific settings */
    return start_common(std::move(doc), settings, router);
}

bool Nettest::start_meek_fronted_requests(settings::MeekFrontedRequestsSettings settings, routers::Router *router) noexcept {
    router = (router) ? router : default_router();
    nlohmann::json doc;
    doc["name"] = "MeekFrontedRequests";
    /* No nettest specific settings */
    return start_common(std::move(doc), settings, router);
}

bool Nettest::start_multi_ndt(settings::MultiNdtSettings settings, routers::Router *router) noexcept {
    router = (router) ? router : default_router();
    nlohmann::json doc;
    doc["name"] = "MultiNdt";
    /* No nettest specific settings */
    return start_common(std::move(doc), settings, router);
}

bool Nettest::start_ndt(settings::NdtSettings settings, routers::Router *router) noexcept {
    router = (router) ? router : default_router();
    nlohmann::json doc;
    doc["name"] = "Ndt";
    /* No nettest specific settings */
    return start_common(std::move(doc), settings, router);
}

bool Nettest::start_tcp_connect(settings::TcpConnectSettings settings, routers::Router *router) noexcept {
    router = (router) ? router : default_router();
    nlohmann::json doc;
    doc["name"] = "TcpConnect";
    /* No nettest specific settings */
    return start_common(std::move(doc), settings, router);
}

bool Nettest::start_telegram(settings::TelegramSettings settings, routers::Router *router) noexcept {
    router = (router) ? router : default_router();
    nlohmann::json doc;
    doc["name"] = "Telegram";
    /* No nettest specific settings */
    return start_common(std::move(doc), settings, router);
}

bool Nettest::start_web_connectivity(settings::WebConnectivitySettings settings, routers::Router *router) noexcept {
    router = (router) ? router : default_router();
    nlohmann::json doc;
    doc["name"] = "WebConnectivity";
    /* No nettest specific settings */
    return start_common(std::move(doc), settings, router);
}

bool Nettest::start_whatsapp(settings::WhatsappSettings settings, routers::Router *router) noexcept {
    router = (router) ? router : default_router();
    nlohmann::json doc;
    doc["name"] = "Whatsapp";
    doc["options"]["all_endpoints"] = (int64_t)settings.all_endpoints;
    return start_common(std::move(doc), settings, router);
}

void Nettest::route_next_event(routers::Router *router) noexcept {
    router = (router) ? router : default_router();
    UniqueEvent eventptr;
    nlohmann::json ev;
    {
        std::unique_lock<std::mutex> _{mutex_};
        eventptr.reset(mk_task_wait_for_next_event(task_.get()));
    }
    if (eventptr == nullptr) {
        // TODO(bassosimone): route this error.
        interrupt();
        return;
    }
    auto str = mk_event_serialize(eventptr.get());
    if (!str) {
        // TODO(bassosimone): route this error.
        interrupt();
        return;
    }
#ifdef MK_NETTEST_TRACE
    std::clog << "NETTEST: event: " << str << std::endl;
#endif
    try {
        ev = nlohmann::json::parse(str);
    } catch (const std::exception &) {
        // TODO(bassosimone): route this error.
        interrupt();
        return;
    }
    if (ev.count("key") <= 0 || !ev.at("key").is_string() || ev.count("value") <= 0 || !ev.at("value").is_object()) {
        // TODO(bassosimone): route this error.
        interrupt();
        return;
    }
    if (ev.at("key") == events::FailureAsnLookupEvent::key) {
        events::FailureAsnLookupEvent event;
        if (ev.at("value").count("failure") <= 0 || !ev.at("value").at("failure").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.failure = ev.at("value").at("failure");
        router->on_failure_asn_lookup(event);
        return;
    }
    if (ev.at("key") == events::FailureCcLookupEvent::key) {
        events::FailureCcLookupEvent event;
        if (ev.at("value").count("failure") <= 0 || !ev.at("value").at("failure").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.failure = ev.at("value").at("failure");
        router->on_failure_cc_lookup(event);
        return;
    }
    if (ev.at("key") == events::FailureIpLookupEvent::key) {
        events::FailureIpLookupEvent event;
        if (ev.at("value").count("failure") <= 0 || !ev.at("value").at("failure").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.failure = ev.at("value").at("failure");
        router->on_failure_ip_lookup(event);
        return;
    }
    if (ev.at("key") == events::FailureMeasurementEvent::key) {
        events::FailureMeasurementEvent event;
        if (ev.at("value").count("failure") <= 0 || !ev.at("value").at("failure").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.failure = ev.at("value").at("failure");
        router->on_failure_measurement(event);
        return;
    }
    if (ev.at("key") == events::FailureMeasurementSubmissionEvent::key) {
        events::FailureMeasurementSubmissionEvent event;
        if (ev.at("value").count("failure") <= 0 || !ev.at("value").at("failure").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.failure = ev.at("value").at("failure");
        if (ev.at("value").count("idx") <= 0 || !ev.at("value").at("idx").is_number_integer()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.idx = ev.at("value").at("idx");
        if (ev.at("value").count("json_str") <= 0 || !ev.at("value").at("json_str").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.json_str = ev.at("value").at("json_str");
        router->on_failure_measurement_submission(event);
        return;
    }
    if (ev.at("key") == events::FailureReportCreateEvent::key) {
        events::FailureReportCreateEvent event;
        if (ev.at("value").count("failure") <= 0 || !ev.at("value").at("failure").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.failure = ev.at("value").at("failure");
        router->on_failure_report_create(event);
        return;
    }
    if (ev.at("key") == events::FailureReportCloseEvent::key) {
        events::FailureReportCloseEvent event;
        if (ev.at("value").count("failure") <= 0 || !ev.at("value").at("failure").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.failure = ev.at("value").at("failure");
        router->on_failure_report_close(event);
        return;
    }
    if (ev.at("key") == events::FailureResolverLookupEvent::key) {
        events::FailureResolverLookupEvent event;
        if (ev.at("value").count("failure") <= 0 || !ev.at("value").at("failure").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.failure = ev.at("value").at("failure");
        router->on_failure_resolver_lookup(event);
        return;
    }
    if (ev.at("key") == events::FailureStartupEvent::key) {
        events::FailureStartupEvent event;
        if (ev.at("value").count("failure") <= 0 || !ev.at("value").at("failure").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.failure = ev.at("value").at("failure");
        router->on_failure_startup(event);
        return;
    }
    if (ev.at("key") == events::LogEvent::key) {
        events::LogEvent event;
        if (ev.at("value").count("log_level") <= 0 || !ev.at("value").at("log_level").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.log_level = ev.at("value").at("log_level");
        if (ev.at("value").count("message") <= 0 || !ev.at("value").at("message").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.message = ev.at("value").at("message");
        router->on_log(event);
        return;
    }
    if (ev.at("key") == events::MeasurementEvent::key) {
        events::MeasurementEvent event;
        if (ev.at("value").count("idx") <= 0 || !ev.at("value").at("idx").is_number_integer()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.idx = ev.at("value").at("idx");
        if (ev.at("value").count("json_str") <= 0 || !ev.at("value").at("json_str").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.json_str = ev.at("value").at("json_str");
        router->on_measurement(event);
        return;
    }
    if (ev.at("key") == events::StatusEndEvent::key) {
        events::StatusEndEvent event;
        if (ev.at("value").count("downloaded_kb") <= 0 || !ev.at("value").at("downloaded_kb").is_number_float()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.downloaded_kb = ev.at("value").at("downloaded_kb");
        if (ev.at("value").count("uploaded_kb") <= 0 || !ev.at("value").at("uploaded_kb").is_number_float()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.uploaded_kb = ev.at("value").at("uploaded_kb");
        if (ev.at("value").count("failure") <= 0 || !ev.at("value").at("failure").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.failure = ev.at("value").at("failure");
        router->on_status_end(event);
        return;
    }
    if (ev.at("key") == events::StatusGeoipLookupEvent::key) {
        events::StatusGeoipLookupEvent event;
        if (ev.at("value").count("probe_ip") <= 0 || !ev.at("value").at("probe_ip").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.probe_ip = ev.at("value").at("probe_ip");
        if (ev.at("value").count("probe_asn") <= 0 || !ev.at("value").at("probe_asn").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.probe_asn = ev.at("value").at("probe_asn");
        if (ev.at("value").count("probe_cc") <= 0 || !ev.at("value").at("probe_cc").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.probe_cc = ev.at("value").at("probe_cc");
        if (ev.at("value").count("probe_network_name") <= 0 || !ev.at("value").at("probe_network_name").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.probe_network_name = ev.at("value").at("probe_network_name");
        router->on_status_geoip_lookup(event);
        return;
    }
    if (ev.at("key") == events::StatusProgressEvent::key) {
        events::StatusProgressEvent event;
        if (ev.at("value").count("percentage") <= 0 || !ev.at("value").at("percentage").is_number_float()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.percentage = ev.at("value").at("percentage");
        if (ev.at("value").count("message") <= 0 || !ev.at("value").at("message").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.message = ev.at("value").at("message");
        router->on_status_progress(event);
        return;
    }
    if (ev.at("key") == events::StatusQueuedEvent::key) {
        events::StatusQueuedEvent event;
        /* No attributes */
        router->on_status_queued(event);
        return;
    }
    if (ev.at("key") == events::StatusMeasurementStartEvent::key) {
        events::StatusMeasurementStartEvent event;
        if (ev.at("value").count("idx") <= 0 || !ev.at("value").at("idx").is_number_integer()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.idx = ev.at("value").at("idx");
        if (ev.at("value").count("input") <= 0 || !ev.at("value").at("input").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.input = ev.at("value").at("input");
        router->on_status_measurement_start(event);
        return;
    }
    if (ev.at("key") == events::StatusMeasurementSubmissionEvent::key) {
        events::StatusMeasurementSubmissionEvent event;
        if (ev.at("value").count("idx") <= 0 || !ev.at("value").at("idx").is_number_integer()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.idx = ev.at("value").at("idx");
        router->on_status_measurement_submission(event);
        return;
    }
    if (ev.at("key") == events::StatusMeasurementDoneEvent::key) {
        events::StatusMeasurementDoneEvent event;
        if (ev.at("value").count("idx") <= 0 || !ev.at("value").at("idx").is_number_integer()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.idx = ev.at("value").at("idx");
        router->on_status_measurement_done(event);
        return;
    }
    if (ev.at("key") == events::StatusReportCloseEvent::key) {
        events::StatusReportCloseEvent event;
        if (ev.at("value").count("report_id") <= 0 || !ev.at("value").at("report_id").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.report_id = ev.at("value").at("report_id");
        router->on_status_report_close(event);
        return;
    }
    if (ev.at("key") == events::StatusReportCreateEvent::key) {
        events::StatusReportCreateEvent event;
        if (ev.at("value").count("report_id") <= 0 || !ev.at("value").at("report_id").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.report_id = ev.at("value").at("report_id");
        router->on_status_report_create(event);
        return;
    }
    if (ev.at("key") == events::StatusResolverLookupEvent::key) {
        events::StatusResolverLookupEvent event;
        if (ev.at("value").count("ip_address") <= 0 || !ev.at("value").at("ip_address").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.ip_address = ev.at("value").at("ip_address");
        router->on_status_resolver_lookup(event);
        return;
    }
    if (ev.at("key") == events::StatusStartedEvent::key) {
        events::StatusStartedEvent event;
        /* No attributes */
        router->on_status_started(event);
        return;
    }
    if (ev.at("key") == events::StatusUpdatePerformanceEvent::key) {
        events::StatusUpdatePerformanceEvent event;
        if (ev.at("value").count("direction") <= 0 || !ev.at("value").at("direction").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.direction = ev.at("value").at("direction");
        if (ev.at("value").count("elapsed") <= 0 || !ev.at("value").at("elapsed").is_number_float()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.elapsed = ev.at("value").at("elapsed");
        if (ev.at("value").count("num_streams") <= 0 || !ev.at("value").at("num_streams").is_number_integer()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.num_streams = ev.at("value").at("num_streams");
        if (ev.at("value").count("speed_kbps") <= 0 || !ev.at("value").at("speed_kbps").is_number_float()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.speed_kbps = ev.at("value").at("speed_kbps");
        router->on_status_update_performance(event);
        return;
    }
    if (ev.at("key") == events::StatusUpdateWebsitesEvent::key) {
        events::StatusUpdateWebsitesEvent event;
        if (ev.at("value").count("url") <= 0 || !ev.at("value").at("url").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.url = ev.at("value").at("url");
        if (ev.at("value").count("status") <= 0 || !ev.at("value").at("status").is_string()) {
            // TODO(bassosimone): route this error.
            interrupt();
            return;
        }
        event.status = ev.at("value").at("status");
        router->on_status_update_websites(event);
        return;
    }
    if (ev.at("key") == events::TaskTerminatedEvent::key) {
        events::TaskTerminatedEvent event;
        /* No attributes */
        router->on_task_terminated(event);
        return;
    }
#ifdef MK_NETTEST_TRACE
    std::clog << "NETTEST: unhandled event: " << str << std::endl;
#endif
    // TODO(bassosimone): route this error.
    interrupt();
}

bool Nettest::is_done() noexcept {
    std::unique_lock<std::mutex> _{mutex_};
    return mk_task_is_done(task_.get());
}

void Nettest::interrupt() noexcept {
    std::unique_lock<std::mutex> _{mutex_};
    mk_task_interrupt(task_.get());
}

/* static */ routers::Router *Nettest::default_router() noexcept {
    static routers::Router router;
    return &router;
}

bool Nettest::start_common(nlohmann::json doc, const settings::CommonSettings &cs, routers::Router *router) noexcept {
    assert(router != nullptr);

    doc["annotations"] = cs.annotations;
    doc["disabled_events"] = cs.disabled_events;
    doc["inputs"] = cs.inputs;
    doc["input_filepaths"] = cs.input_filepaths;
    doc["log_filepath"] = cs.log_filepath;
    doc["log_level"] = cs.log_level;
    doc["output_filepath"] = cs.output_filepath;
    {
        auto &o = doc["options"];
        o["bouncer_base_url"] = cs.bouncer_base_url;
        o["collector_base_url"] = cs.collector_base_url;
        o["dns/nameserver"] = cs.dns_nameserver;
        o["dns/engine"] = cs.dns_engine;
        o["geoip_asn_path"] = cs.geoip_asn_path;
        o["geoip_country_path"] = cs.geoip_country_path;
        o["ignore_bouncer_error"] = (int64_t)cs.ignore_bouncer_error;
        o["ignore_open_report_error"] = (int64_t)cs.ignore_open_report_error;
        o["max_runtime"] = cs.max_runtime;
        o["net/ca_bundle_path"] = cs.net_ca_bundle_path;
        o["net/timeout"] = cs.net_timeout;
        o["no_bouncer"] = (int64_t)cs.no_bouncer;
        o["no_collector"] = (int64_t)cs.no_collector;
        o["no_asn_lookup"] = (int64_t)cs.no_asn_lookup;
        o["no_cc_lookup"] = (int64_t)cs.no_cc_lookup;
        o["no_ip_lookup"] = (int64_t)cs.no_ip_lookup;
        o["no_file_report"] = (int64_t)cs.no_file_report;
        o["no_resolver_lookup"] = (int64_t)cs.no_resolver_lookup;
        o["probe_asn"] = cs.probe_asn;
        o["probe_cc"] = cs.probe_cc;
        o["probe_ip"] = cs.probe_ip;
        o["randomize_input"] = (int64_t)cs.randomize_input;
        o["save_real_probe_asn"] = (int64_t)cs.save_real_probe_asn;
        o["save_real_probe_cc"] = (int64_t)cs.save_real_probe_cc;
        o["save_real_probe_ip"] = (int64_t)cs.save_real_probe_ip;
        o["save_real_resolver_ip"] = (int64_t)cs.save_real_resolver_ip;
        o["software_name"] = cs.software_name;
        o["software_version"] = cs.software_version;
    }

    std::unique_lock<std::mutex> _{mutex_};
    if (task_ != nullptr) {
        // TODO(bassosimone): route this error.
        return false;
    }
    std::string str;
    try {
        str = doc.dump();
    } catch (const std::exception &) {
        // TODO(bassosimone): route this error.
        return false;
    }
#ifdef MK_NETTEST_TRACE
    std::clog << "NETTEST: settings: " << str << std::endl;
#endif

    task_.reset(mk_task_start(str.c_str()));
    if (task_ == nullptr) {
        // TODO(bassosimone): route this error.
        return false;
    }
    return true;
}

#endif // !MK_NETTEST_NO_INLINE_IMPL && !SWIG
} // namespace nettest
} // namespace mk
#endif // MEASUREMENT_KIT_NETTEST_HPP
