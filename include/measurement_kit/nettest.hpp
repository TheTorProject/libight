// Part of Measurement Kit <https://measurement-kit.github.io/>.
// Measurement Kit is free software under the BSD license. See AUTHORS
// and LICENSE for more information on the copying conditions.
#ifndef MEASUREMENT_KIT_NETTEST_HPP
#define MEASUREMENT_KIT_NETTEST_HPP

/*-
 *  __      __  _____ __________  _______  .___ _______    ________
 * /  \    /  \/  _  \\______   \ \      \ |   |\      \  /  _____/
 * \   \/\/   /  /_\  \|       _/ /   |   \|   |/   |   \/   \  ___
 *  \        /    |    \    |   \/    |    \   /    |    \    \_\  \
 *   \__/\  /\____|__  /____|_  /\____|__  /___\____|__  /\______  /
 *        \/         \/       \/         \/            \/        \/
 *
 * Autogenerated by `./script/autoapi/autoapi`. DO NOT EDIT!!!
 */

/// \file include/measurement_kit/nettest.hpp
///
/// \brief C++11 API for running nettests.
///
/// The general concept of this API is that a network test (nettest) requires
/// some configuration for running. While running, it emits events, that you
/// may or may not want to handle. Nettests run in a background thread managed
/// by a Runner class, which also allows you to interrupt a nettest. Within the
/// same runner instance, nettests will run in FIFO order.
///
/// Usage is as follows:
///
/// 1. subclass Runner and implement the virtual methods representing the
///    events that you would like to handle. Remember that callbacks are
///    going to be called from the runner's background thread.
///
/// ```
/// class MyRunner : public mk::nettest::Runner {
///  public:
///   using mk::nettest::Runner::Runner;
///
///   void on_log(const LogEvent &event) override {
///     // Your event handling code here. Remember that this is called
///     // in the context of the runner's background thread.
///   }
///
///  private:
///   // Your implementation variables here
/// }
/// ```
///
/// 2. create an instance of your runner. You may either want to have an
///    instance for each nettest or to have a global instance. When you
///    create your runner, this will also create a thread for running tests
///    in the context of such runner, and a queue where to queue tests if
///    more than a single nettest is submitted to that runner concurrently.
///
///    If you are using multiple runners, MK will still guarantee that
///    nettests will not run concurrently. However, in this case,
///    there is no guarantee on the order with which each runner is going
///    to run its nettests. The FFI API, in fact, internally use a semaphore
///    that does not provide any FIFO guarantee.
///
/// ```
/// auto runner = std::make_shared<MyRunner>();
/// ```
///
/// 3. to create a nettest, instantiate the corresponding settings class
///    and set both the common and nettest-specific fields you need.
///
///    When manipulating settings from C++, you can use booleans. We will
///    automatically convert them to integers for the FFI API.
///
/// ```
/// extern void set_more_common_settings(mk::nettest::CommonSettings *);
///
/// WhatsappSettings settings;
/// settings.all_endpoints = true;
/// settings.log_level = settings.log_level_info;
/// set_more_common_settings(&settings);
/// ```
///
/// 4. to run a nettest, pass the settings to the specific method of
///    the runner. This will schedule the test for running in the internal
///    queue in FIFO order in the context of the runner's thread.
///
/// ```
/// runner->schedule_whatsapp(std::move(settings));
/// ```
///
/// 5. the test will then be running (possibly waiting for other nettests
///    scheduled on the same runner to terminate). Errors occuring when
///    starting up and/or running the test will be routed as events. You
///    can interrupt the currently running nettest, if you wish.
///
/// ```
/// runner->interrupt();
/// ```
///
/// 6. if the runner goes out of scope, the currently running nettest is
///    interrupted and no further nettests will run.

#include <assert.h>
#include <stdint.h>

#include <deque>
#include <iostream>
#include <map>
#include <memory>
#include <mutex>
#include <sstream>
#include <string>
#include <thread>
#include <utility>
#include <vector>

#include <measurement_kit/common/nlohmann/json.hpp>
#include <measurement_kit/ffi.h>

namespace mk {
namespace nettest {

// Events
// ------

/// C++ representation of the "failure.asn_lookup" event.
class FailureAsnLookupEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "failure.asn_lookup";
    
    /// The "failure" attribute of this event.
    std::string failure = {};
};

/// C++ representation of the "failure.cc_lookup" event.
class FailureCcLookupEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "failure.cc_lookup";
    
    /// The "failure" attribute of this event.
    std::string failure = {};
};

/// C++ representation of the "failure.ip_lookup" event.
class FailureIpLookupEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "failure.ip_lookup";
    
    /// The "failure" attribute of this event.
    std::string failure = {};
};

/// C++ representation of the "failure.measurement" event.
class FailureMeasurementEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "failure.measurement";
    
    /// The "failure" attribute of this event.
    std::string failure = {};
};

/// C++ representation of the "failure.measurement_submission" event.
class FailureMeasurementSubmissionEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "failure.measurement_submission";
    
    /// The "failure" attribute of this event.
    std::string failure = {};
    
    /// The "idx" attribute of this event.
    int64_t idx = {};
    
    /// The "json_str" attribute of this event.
    std::string json_str = {};
};

/// C++ representation of the "failure.report_create" event.
class FailureReportCreateEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "failure.report_create";
    
    /// The "failure" attribute of this event.
    std::string failure = {};
};

/// C++ representation of the "failure.report_close" event.
class FailureReportCloseEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "failure.report_close";
    
    /// The "failure" attribute of this event.
    std::string failure = {};
};

/// C++ representation of the "failure.resolver_lookup" event.
class FailureResolverLookupEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "failure.resolver_lookup";
    
    /// The "failure" attribute of this event.
    std::string failure = {};
};

/// C++ representation of the "failure.startup" event.
class FailureStartupEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "failure.startup";
    
    /// The "failure" attribute of this event.
    std::string failure = {};
};

/// C++ representation of the "log" event.
class LogEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "log";
    
    /// The "log_level" attribute of this event.
    std::string log_level = {};
    
    /// The "message" attribute of this event.
    std::string message = {};
};

/// C++ representation of the "measurement" event.
class MeasurementEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "measurement";
    
    /// The "idx" attribute of this event.
    int64_t idx = {};
    
    /// The "json_str" attribute of this event.
    std::string json_str = {};
};

/// C++ representation of the "status.end" event.
class StatusEndEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.end";
    
    /// The "downloaded_kb" attribute of this event.
    double downloaded_kb = {};
    
    /// The "uploaded_kb" attribute of this event.
    double uploaded_kb = {};
    
    /// The "failure" attribute of this event.
    std::string failure = {};
};

/// C++ representation of the "status.geoip_lookup" event.
class StatusGeoipLookupEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.geoip_lookup";
    
    /// The "probe_ip" attribute of this event.
    std::string probe_ip = {};
    
    /// The "probe_asn" attribute of this event.
    std::string probe_asn = {};
    
    /// The "probe_cc" attribute of this event.
    std::string probe_cc = {};
    
    /// The "probe_network_name" attribute of this event.
    std::string probe_network_name = {};
};

/// C++ representation of the "status.progress" event.
class StatusProgressEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.progress";
    
    /// The "percentage" attribute of this event.
    double percentage = {};
    
    /// The "message" attribute of this event.
    std::string message = {};
};

/// C++ representation of the "status.queued" event.
class StatusQueuedEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.queued";
    /* No attributes */
};

/// C++ representation of the "status.measurement_start" event.
class StatusMeasurementStartEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.measurement_start";
    
    /// The "idx" attribute of this event.
    int64_t idx = {};
    
    /// The "input" attribute of this event.
    std::string input = {};
};

/// C++ representation of the "status.measurement_submission" event.
class StatusMeasurementSubmissionEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.measurement_submission";
    
    /// The "idx" attribute of this event.
    int64_t idx = {};
};

/// C++ representation of the "status.measurement_done" event.
class StatusMeasurementDoneEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.measurement_done";
    
    /// The "idx" attribute of this event.
    int64_t idx = {};
};

/// C++ representation of the "status.report_close" event.
class StatusReportCloseEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.report_close";
    
    /// The "report_id" attribute of this event.
    std::string report_id = {};
};

/// C++ representation of the "status.report_create" event.
class StatusReportCreateEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.report_create";
    
    /// The "report_id" attribute of this event.
    std::string report_id = {};
};

/// C++ representation of the "status.resolver_lookup" event.
class StatusResolverLookupEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.resolver_lookup";
    
    /// The "ip_address" attribute of this event.
    std::string ip_address = {};
};

/// C++ representation of the "status.started" event.
class StatusStartedEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.started";
    /* No attributes */
};

/// C++ representation of the "status.update.performance" event.
class StatusUpdatePerformanceEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.update.performance";
    
    /// The "direction" attribute of this event.
    std::string direction = {};
    
    /// The "elapsed" attribute of this event.
    double elapsed = {};
    
    /// The "num_streams" attribute of this event.
    int64_t num_streams = {};
    
    /// The "speed_kbps" attribute of this event.
    double speed_kbps = {};
};

/// C++ representation of the "status.update.websites" event.
class StatusUpdateWebsitesEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "status.update.websites";
    
    /// The "url" attribute of this event.
    std::string url = {};
    
    /// The "status" attribute of this event.
    std::string status = {};
};

/// C++ representation of the "task_terminated" event.
class TaskTerminatedEvent {
  public:
    /// The unique identifier of this event.
    static constexpr const char *key = "task_terminated";
    /* No attributes */
};

// Settings
// --------

/// Settings common to all nettests.
class CommonSettings {
  public:
    /// String representation of the "err" log level.
    static constexpr const char *log_level_err = "ERR";

    /// String representation of the "warning" log level.
    static constexpr const char *log_level_warning = "WARNING";

    /// String representation of the "info" log level.
    static constexpr const char *log_level_info = "INFO";

    /// String representation of the "debug" log level.
    static constexpr const char *log_level_debug = "DEBUG";

    /// String representation of the "debug2" log level.
    static constexpr const char *log_level_debug2 = "DEBUG2";

    /// The "annotations" setting.
    std::map<std::string, std::string> annotations = {};

    /// The "disabled_events" setting.
    std::vector<std::string> disabled_events = {};

    /// The "inputs" setting.
    std::vector<std::string> inputs = {};

    /// The "input_filepaths" setting.
    std::vector<std::string> input_filepaths = {};

    /// The "log_filepath" setting.
    std::string log_filepath = {};

    /// The "log_level" setting.
    std::string log_level = log_level_err;

    /// The "output_filepath" setting.
    std::string output_filepath = {};

    /// The "bouncer_base_url" setting.
    std::string bouncer_base_url = "https://bouncer.ooni.io";

    /// The "collector_base_url" setting.
    std::string collector_base_url = {};

    /// The "dns/nameserver" setting.
    std::string dns_nameserver = {};

    /// The "dns/engine" setting.
    std::string dns_engine = "system";

    /// The "geoip_asn_path" setting.
    std::string geoip_asn_path = {};

    /// The "geoip_country_path" setting.
    std::string geoip_country_path = {};

    /// The "ignore_bouncer_error" setting.
    bool ignore_bouncer_error = true;

    /// The "ignore_open_report_error" setting.
    bool ignore_open_report_error = true;

    /// The "max_runtime" setting.
    double max_runtime = -1.0;

    /// The "net/ca_bundle_path" setting.
    std::string net_ca_bundle_path = {};

    /// The "net/timeout" setting.
    double net_timeout = 10.0;

    /// The "no_bouncer" setting.
    bool no_bouncer = false;

    /// The "no_collector" setting.
    bool no_collector = false;

    /// The "no_asn_lookup" setting.
    bool no_asn_lookup = false;

    /// The "no_cc_lookup" setting.
    bool no_cc_lookup = false;

    /// The "no_ip_lookup" setting.
    bool no_ip_lookup = false;

    /// The "no_file_report" setting.
    bool no_file_report = false;

    /// The "no_resolver_lookup" setting.
    bool no_resolver_lookup = false;

    /// The "probe_asn" setting.
    std::string probe_asn = {};

    /// The "probe_cc" setting.
    std::string probe_cc = {};

    /// The "probe_ip" setting.
    std::string probe_ip = {};

    /// The "randomize_input" setting.
    bool randomize_input = true;

    /// The "save_real_probe_asn" setting.
    bool save_real_probe_asn = true;

    /// The "save_real_probe_cc" setting.
    bool save_real_probe_cc = true;

    /// The "save_real_probe_ip" setting.
    bool save_real_probe_ip = false;

    /// The "save_real_resolver_ip" setting.
    bool save_real_resolver_ip = true;

    /// The "software_name" setting.
    std::string software_name = {};

    /// The "software_version" setting.
    std::string software_version = {};
};

/// Settings of the "CaptivePortal" nettest.
class CaptivePortalSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "CaptivePortal";
    /* No nettest-specific settings */
};

/// Settings of the "Dash" nettest.
class DashSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "Dash";
    /* No nettest-specific settings */
};

/// Settings of the "DnsInjection" nettest.
class DnsInjectionSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "DnsInjection";
    /* No nettest-specific settings */
};

/// Settings of the "FacebookMessenger" nettest.
class FacebookMessengerSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "FacebookMessenger";
    /* No nettest-specific settings */
};

/// Settings of the "HttpHeaderFieldManipulation" nettest.
class HttpHeaderFieldManipulationSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "HttpHeaderFieldManipulation";
    /* No nettest-specific settings */
};

/// Settings of the "HttpInvalidRequestLine" nettest.
class HttpInvalidRequestLineSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "HttpInvalidRequestLine";
    /* No nettest-specific settings */
};

/// Settings of the "MeekFrontedRequests" nettest.
class MeekFrontedRequestsSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "MeekFrontedRequests";
    /* No nettest-specific settings */
};

/// Settings of the "MultiNdt" nettest.
class MultiNdtSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "MultiNdt";
    /* No nettest-specific settings */
};

/// Settings of the "Ndt" nettest.
class NdtSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "Ndt";
    /* No nettest-specific settings */
};

/// Settings of the "TcpConnect" nettest.
class TcpConnectSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "TcpConnect";
    /* No nettest-specific settings */
};

/// Settings of the "Telegram" nettest.
class TelegramSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "Telegram";
    /* No nettest-specific settings */
};

/// Settings of the "WebConnectivity" nettest.
class WebConnectivitySettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "WebConnectivity";
    /* No nettest-specific settings */
};

/// Settings of the "Whatsapp" nettest.
class WhatsappSettings : public CommonSettings {
  public:
    /// Unique name of this nettest.
    static constexpr const char *name = "Whatsapp";
    
    /// The "all_endpoints" setting of this nettest.
    bool all_endpoints = false;
};

// Runners
// -------

/// Runs nettests. Nettests are queued and run in FIFO order. They run on a
/// background thread having the same lifecycle of this class.
class Runner {
  public:
    // Handlers
    // ````````
    // Implementation note: virtual methods cannot be `noexcept` because the
    // task stable version of SWIG does not handle that correctly.

    /// Handles the "failure.asn_lookup" event.
    virtual void on_failure_asn_lookup(const FailureAsnLookupEvent &event);

    /// Handles the "failure.cc_lookup" event.
    virtual void on_failure_cc_lookup(const FailureCcLookupEvent &event);

    /// Handles the "failure.ip_lookup" event.
    virtual void on_failure_ip_lookup(const FailureIpLookupEvent &event);

    /// Handles the "failure.measurement" event.
    virtual void on_failure_measurement(const FailureMeasurementEvent &event);

    /// Handles the "failure.measurement_submission" event.
    virtual void on_failure_measurement_submission(const FailureMeasurementSubmissionEvent &event);

    /// Handles the "failure.report_create" event.
    virtual void on_failure_report_create(const FailureReportCreateEvent &event);

    /// Handles the "failure.report_close" event.
    virtual void on_failure_report_close(const FailureReportCloseEvent &event);

    /// Handles the "failure.resolver_lookup" event.
    virtual void on_failure_resolver_lookup(const FailureResolverLookupEvent &event);

    /// Handles the "failure.startup" event.
    virtual void on_failure_startup(const FailureStartupEvent &event);

    /// Handles the "log" event.
    virtual void on_log(const LogEvent &event);

    /// Handles the "measurement" event.
    virtual void on_measurement(const MeasurementEvent &event);

    /// Handles the "status.end" event.
    virtual void on_status_end(const StatusEndEvent &event);

    /// Handles the "status.geoip_lookup" event.
    virtual void on_status_geoip_lookup(const StatusGeoipLookupEvent &event);

    /// Handles the "status.progress" event.
    virtual void on_status_progress(const StatusProgressEvent &event);

    /// Handles the "status.queued" event.
    virtual void on_status_queued(const StatusQueuedEvent &event);

    /// Handles the "status.measurement_start" event.
    virtual void on_status_measurement_start(const StatusMeasurementStartEvent &event);

    /// Handles the "status.measurement_submission" event.
    virtual void on_status_measurement_submission(const StatusMeasurementSubmissionEvent &event);

    /// Handles the "status.measurement_done" event.
    virtual void on_status_measurement_done(const StatusMeasurementDoneEvent &event);

    /// Handles the "status.report_close" event.
    virtual void on_status_report_close(const StatusReportCloseEvent &event);

    /// Handles the "status.report_create" event.
    virtual void on_status_report_create(const StatusReportCreateEvent &event);

    /// Handles the "status.resolver_lookup" event.
    virtual void on_status_resolver_lookup(const StatusResolverLookupEvent &event);

    /// Handles the "status.started" event.
    virtual void on_status_started(const StatusStartedEvent &event);

    /// Handles the "status.update.performance" event.
    virtual void on_status_update_performance(const StatusUpdatePerformanceEvent &event);

    /// Handles the "status.update.websites" event.
    virtual void on_status_update_websites(const StatusUpdateWebsitesEvent &event);

    /// Handles the "task_terminated" event.
    virtual void on_task_terminated(const TaskTerminatedEvent &event);

    // Runners
    // ```````

    /// Schedules running the "CaptivePortal" nettest in the background thread.
    /// \param settings Nettest specific settings.
    void schedule_captive_portal(CaptivePortalSettings settings) noexcept;

    /// Schedules running the "Dash" nettest in the background thread.
    /// \param settings Nettest specific settings.
    void schedule_dash(DashSettings settings) noexcept;

    /// Schedules running the "DnsInjection" nettest in the background thread.
    /// \param settings Nettest specific settings.
    void schedule_dns_injection(DnsInjectionSettings settings) noexcept;

    /// Schedules running the "FacebookMessenger" nettest in the background thread.
    /// \param settings Nettest specific settings.
    void schedule_facebook_messenger(FacebookMessengerSettings settings) noexcept;

    /// Schedules running the "HttpHeaderFieldManipulation" nettest in the background thread.
    /// \param settings Nettest specific settings.
    void schedule_http_header_field_manipulation(HttpHeaderFieldManipulationSettings settings) noexcept;

    /// Schedules running the "HttpInvalidRequestLine" nettest in the background thread.
    /// \param settings Nettest specific settings.
    void schedule_http_invalid_request_line(HttpInvalidRequestLineSettings settings) noexcept;

    /// Schedules running the "MeekFrontedRequests" nettest in the background thread.
    /// \param settings Nettest specific settings.
    void schedule_meek_fronted_requests(MeekFrontedRequestsSettings settings) noexcept;

    /// Schedules running the "MultiNdt" nettest in the background thread.
    /// \param settings Nettest specific settings.
    void schedule_multi_ndt(MultiNdtSettings settings) noexcept;

    /// Schedules running the "Ndt" nettest in the background thread.
    /// \param settings Nettest specific settings.
    void schedule_ndt(NdtSettings settings) noexcept;

    /// Schedules running the "TcpConnect" nettest in the background thread.
    /// \param settings Nettest specific settings.
    void schedule_tcp_connect(TcpConnectSettings settings) noexcept;

    /// Schedules running the "Telegram" nettest in the background thread.
    /// \param settings Nettest specific settings.
    void schedule_telegram(TelegramSettings settings) noexcept;

    /// Schedules running the "WebConnectivity" nettest in the background thread.
    /// \param settings Nettest specific settings.
    void schedule_web_connectivity(WebConnectivitySettings settings) noexcept;

    /// Schedules running the "Whatsapp" nettest in the background thread.
    /// \param settings Nettest specific settings.
    void schedule_whatsapp(WhatsappSettings settings) noexcept;

    // Other methods
    // `````````````

    /// Interrupts the currently running nettest. \remark you can safely
    /// call this method from any thread.
    void interrupt() noexcept;

    /// Interrupts the currently running nettest and join its thread.
    virtual ~Runner() noexcept;

    /// Creates a runner.
    Runner() noexcept;

  private:
    // Common method to schedule a nettest.
    void schedule(nlohmann::json, const CommonSettings &) noexcept;

    // Method that runs a nettest.
    void run_one(nlohmann::json) noexcept;

    // Implementation details of this class.
    class Impl;

    // Unique pointer to the internals.
    std::unique_ptr<Impl> impl_;
};

/*-
 * __________        .__               __
 * \______   \_______|__|__  _______ _/  |_  ____
 *  |     ___/\_  __ \  \  \/ /\__  \\   __\/ __ \
 *  |    |     |  | \/  |\   /  / __ \|  | \  ___/
 *  |____|     |__|  |__| \_/  (____  /__|  \___  >
 *                                  \/          \/
 *
 * Definitions ends here. What follows is the inline implementation of this
 * API, which you can exclude by setting MK_NETTEST_NO_INLINE_IMPL.
 *
 * This is handy if you want to include this code in many translation
 * units to include the implementation into a single object.
 */
#if !defined MK_NETTEST_NO_INLINE_IMPL && !defined SWIG

// Utility classes
// ---------------

// Deleter for mk_task_t.
class TaskDeleter {
  public:
    void operator()(mk_task_t *task) noexcept { mk_task_destroy(task); }
};

// Syntactic sugar of a unique mk_task_t pointer.
using UniqueTask = std::unique_ptr<mk_task_t, TaskDeleter>;

// Deleter for mk_event_t.
class EventDeleter {
  public:
    void operator()(mk_event_t *event) noexcept { mk_event_destroy(event); }
};

// Syntactic sugar for a unique mk_event_t pointer.
using UniqueEvent = std::unique_ptr<mk_event_t, EventDeleter>;

// Runner
// ------

// Internal implementation of Runner
class Runner::Impl {
  public:
    std::condition_variable cond;       // We have cond nettests
    std::deque<nlohmann::json> deque;   // Queue of deque nettests
    std::atomic_bool dying{false};      // We are dying
    std::mutex mutex;                   // Lock for thread safety
    UniqueTask task;                    // Nettest that is currently running
    std::thread thread;                 // Thread for running nettests
};

// Default handler of the "failure.asn_lookup" event.
void Runner::on_failure_asn_lookup(const FailureAsnLookupEvent &) {}

// Default handler of the "failure.cc_lookup" event.
void Runner::on_failure_cc_lookup(const FailureCcLookupEvent &) {}

// Default handler of the "failure.ip_lookup" event.
void Runner::on_failure_ip_lookup(const FailureIpLookupEvent &) {}

// Default handler of the "failure.measurement" event.
void Runner::on_failure_measurement(const FailureMeasurementEvent &) {}

// Default handler of the "failure.measurement_submission" event.
void Runner::on_failure_measurement_submission(const FailureMeasurementSubmissionEvent &) {}

// Default handler of the "failure.report_create" event.
void Runner::on_failure_report_create(const FailureReportCreateEvent &) {}

// Default handler of the "failure.report_close" event.
void Runner::on_failure_report_close(const FailureReportCloseEvent &) {}

// Default handler of the "failure.resolver_lookup" event.
void Runner::on_failure_resolver_lookup(const FailureResolverLookupEvent &) {}

// Default handler of the "failure.startup" event.
void Runner::on_failure_startup(const FailureStartupEvent &) {}

// Default handler of the "log" event.
void Runner::on_log(const LogEvent &) {}

// Default handler of the "measurement" event.
void Runner::on_measurement(const MeasurementEvent &) {}

// Default handler of the "status.end" event.
void Runner::on_status_end(const StatusEndEvent &) {}

// Default handler of the "status.geoip_lookup" event.
void Runner::on_status_geoip_lookup(const StatusGeoipLookupEvent &) {}

// Default handler of the "status.progress" event.
void Runner::on_status_progress(const StatusProgressEvent &) {}

// Default handler of the "status.queued" event.
void Runner::on_status_queued(const StatusQueuedEvent &) {}

// Default handler of the "status.measurement_start" event.
void Runner::on_status_measurement_start(const StatusMeasurementStartEvent &) {}

// Default handler of the "status.measurement_submission" event.
void Runner::on_status_measurement_submission(const StatusMeasurementSubmissionEvent &) {}

// Default handler of the "status.measurement_done" event.
void Runner::on_status_measurement_done(const StatusMeasurementDoneEvent &) {}

// Default handler of the "status.report_close" event.
void Runner::on_status_report_close(const StatusReportCloseEvent &) {}

// Default handler of the "status.report_create" event.
void Runner::on_status_report_create(const StatusReportCreateEvent &) {}

// Default handler of the "status.resolver_lookup" event.
void Runner::on_status_resolver_lookup(const StatusResolverLookupEvent &) {}

// Default handler of the "status.started" event.
void Runner::on_status_started(const StatusStartedEvent &) {}

// Default handler of the "status.update.performance" event.
void Runner::on_status_update_performance(const StatusUpdatePerformanceEvent &) {}

// Default handler of the "status.update.websites" event.
void Runner::on_status_update_websites(const StatusUpdateWebsitesEvent &) {}

// Default handler of the "task_terminated" event.
void Runner::on_task_terminated(const TaskTerminatedEvent &) {}

// Schedule a "CaptivePortal" nettest.
void Runner::schedule_captive_portal(CaptivePortalSettings settings) noexcept {
    nlohmann::json doc;
    doc["name"] = "CaptivePortal";
    /* No nettest specific settings */
    schedule(std::move(doc), settings);
}

// Schedule a "Dash" nettest.
void Runner::schedule_dash(DashSettings settings) noexcept {
    nlohmann::json doc;
    doc["name"] = "Dash";
    /* No nettest specific settings */
    schedule(std::move(doc), settings);
}

// Schedule a "DnsInjection" nettest.
void Runner::schedule_dns_injection(DnsInjectionSettings settings) noexcept {
    nlohmann::json doc;
    doc["name"] = "DnsInjection";
    /* No nettest specific settings */
    schedule(std::move(doc), settings);
}

// Schedule a "FacebookMessenger" nettest.
void Runner::schedule_facebook_messenger(FacebookMessengerSettings settings) noexcept {
    nlohmann::json doc;
    doc["name"] = "FacebookMessenger";
    /* No nettest specific settings */
    schedule(std::move(doc), settings);
}

// Schedule a "HttpHeaderFieldManipulation" nettest.
void Runner::schedule_http_header_field_manipulation(HttpHeaderFieldManipulationSettings settings) noexcept {
    nlohmann::json doc;
    doc["name"] = "HttpHeaderFieldManipulation";
    /* No nettest specific settings */
    schedule(std::move(doc), settings);
}

// Schedule a "HttpInvalidRequestLine" nettest.
void Runner::schedule_http_invalid_request_line(HttpInvalidRequestLineSettings settings) noexcept {
    nlohmann::json doc;
    doc["name"] = "HttpInvalidRequestLine";
    /* No nettest specific settings */
    schedule(std::move(doc), settings);
}

// Schedule a "MeekFrontedRequests" nettest.
void Runner::schedule_meek_fronted_requests(MeekFrontedRequestsSettings settings) noexcept {
    nlohmann::json doc;
    doc["name"] = "MeekFrontedRequests";
    /* No nettest specific settings */
    schedule(std::move(doc), settings);
}

// Schedule a "MultiNdt" nettest.
void Runner::schedule_multi_ndt(MultiNdtSettings settings) noexcept {
    nlohmann::json doc;
    doc["name"] = "MultiNdt";
    /* No nettest specific settings */
    schedule(std::move(doc), settings);
}

// Schedule a "Ndt" nettest.
void Runner::schedule_ndt(NdtSettings settings) noexcept {
    nlohmann::json doc;
    doc["name"] = "Ndt";
    /* No nettest specific settings */
    schedule(std::move(doc), settings);
}

// Schedule a "TcpConnect" nettest.
void Runner::schedule_tcp_connect(TcpConnectSettings settings) noexcept {
    nlohmann::json doc;
    doc["name"] = "TcpConnect";
    /* No nettest specific settings */
    schedule(std::move(doc), settings);
}

// Schedule a "Telegram" nettest.
void Runner::schedule_telegram(TelegramSettings settings) noexcept {
    nlohmann::json doc;
    doc["name"] = "Telegram";
    /* No nettest specific settings */
    schedule(std::move(doc), settings);
}

// Schedule a "WebConnectivity" nettest.
void Runner::schedule_web_connectivity(WebConnectivitySettings settings) noexcept {
    nlohmann::json doc;
    doc["name"] = "WebConnectivity";
    /* No nettest specific settings */
    schedule(std::move(doc), settings);
}

// Schedule a "Whatsapp" nettest.
void Runner::schedule_whatsapp(WhatsappSettings settings) noexcept {
    nlohmann::json doc;
    doc["name"] = "Whatsapp";
    doc["options"]["all_endpoints"] = (int64_t)settings.all_endpoints;
    schedule(std::move(doc), settings);
}

void Runner::interrupt() noexcept {
    // Implementation notes:
    //
    // 1. mk_task_interrupt() gracefully handles `nullptr` and can be
    //    called from another thread context safely
    //
    // 2. we MUST NOT delete the task task because that is owned by
    //    the background thread, which manages its lifecycle
    //
    // 3. locking is required to synchronize with the background thread
    //    on the value contained inside of the unique_ptr
    std::unique_lock<std::mutex> _{impl_->mutex};
    mk_task_interrupt(impl_->task.get());
}

Runner::~Runner() noexcept {
    // Implementation note: no need for locking because all the operations
    // we perform here are either thread safe or already locked.
    impl_->dying = true;
    interrupt();
    impl_->cond.notify_one();
    impl_->thread.join();
}

Runner::Runner() noexcept {
    impl_.reset(new Runner::Impl);
    impl_->thread = std::thread{[this]() {
        for (;;) {
            nlohmann::json doc;
            {
                std::unique_lock<std::mutex> lck{impl_->mutex};
                impl_->cond.wait(lck, [this]() { //
                    return impl_->dying || !impl_->deque.empty();
                });
                if (impl_->dying) {
                    return;
                }
                assert(!impl_->deque.empty());
                std::swap(impl_->deque.front(), doc);
                impl_->deque.pop_front();
            }
            run_one(std::move(doc));
        }
    }};
}

void Runner::schedule(nlohmann::json doc, const CommonSettings &cs) noexcept {
    doc["annotations"] = cs.annotations;
    doc["disabled_events"] = cs.disabled_events;
    doc["inputs"] = cs.inputs;
    doc["input_filepaths"] = cs.input_filepaths;
    doc["log_filepath"] = cs.log_filepath;
    doc["log_level"] = cs.log_level;
    doc["output_filepath"] = cs.output_filepath;
    {
        auto &o = doc["options"];
        o["bouncer_base_url"] = cs.bouncer_base_url;
        o["collector_base_url"] = cs.collector_base_url;
        o["dns/nameserver"] = cs.dns_nameserver;
        o["dns/engine"] = cs.dns_engine;
        o["geoip_asn_path"] = cs.geoip_asn_path;
        o["geoip_country_path"] = cs.geoip_country_path;
        o["ignore_bouncer_error"] = (int64_t)cs.ignore_bouncer_error;
        o["ignore_open_report_error"] = (int64_t)cs.ignore_open_report_error;
        o["max_runtime"] = cs.max_runtime;
        o["net/ca_bundle_path"] = cs.net_ca_bundle_path;
        o["net/timeout"] = cs.net_timeout;
        o["no_bouncer"] = (int64_t)cs.no_bouncer;
        o["no_collector"] = (int64_t)cs.no_collector;
        o["no_asn_lookup"] = (int64_t)cs.no_asn_lookup;
        o["no_cc_lookup"] = (int64_t)cs.no_cc_lookup;
        o["no_ip_lookup"] = (int64_t)cs.no_ip_lookup;
        o["no_file_report"] = (int64_t)cs.no_file_report;
        o["no_resolver_lookup"] = (int64_t)cs.no_resolver_lookup;
        o["probe_asn"] = cs.probe_asn;
        o["probe_cc"] = cs.probe_cc;
        o["probe_ip"] = cs.probe_ip;
        o["randomize_input"] = (int64_t)cs.randomize_input;
        o["save_real_probe_asn"] = (int64_t)cs.save_real_probe_asn;
        o["save_real_probe_cc"] = (int64_t)cs.save_real_probe_cc;
        o["save_real_probe_ip"] = (int64_t)cs.save_real_probe_ip;
        o["save_real_resolver_ip"] = (int64_t)cs.save_real_resolver_ip;
        o["software_name"] = cs.software_name;
        o["software_version"] = cs.software_version;
    }
    {
        std::unique_lock<std::mutex> _{impl_->mutex};
        impl_->deque.push_back(std::move(doc));
    }
    impl_->cond.notify_one();
}

void Runner::run_one(nlohmann::json doc) noexcept {
    std::string str;
    try {
        str = doc.dump();
    } catch (const std::exception &) {
        // TODO(bassosimone): route this error.
        return;
    }
#ifdef MK_NETTEST_TRACE
    std::clog << "NETTEST: settings: " << str << std::endl;
#endif
    {
        // Implementation note: when we're changing the `task` field we need
        // to do so in a synchronized way because of interrupt().
        std::unique_lock<std::mutex> _{impl_->mutex};
        impl_->task.reset(mk_task_start(str.c_str()));
    }
    if (!impl_->task) {
        // TODO(bassosimone): route this error.
        return;
    }

    while (!mk_task_is_done(impl_->task.get())) {
        nlohmann::json ev;
        {
            UniqueEvent event{mk_task_wait_for_next_event(impl_->task.get())};
            if (!event) {
                // TODO(bassosimone): route this error.
                break;
            }
            auto str = mk_event_serialize(event.get());
            if (!str) {
                // TODO(bassosimone): route this error.
                break;
            }
#ifdef MK_NETTEST_TRACE
            std::clog << "NETTEST: event: " << str << std::endl;
#endif
            try {
                ev = nlohmann::json::parse(str);
            } catch (const std::exception &) {
                // TODO(bassosimone): route this error.
                break;
            }
        }

        if (ev.count("key") <= 0 || !ev.at("key").is_string() || ev.count("value") <= 0 || !ev.at("value").is_object()) {
            // TODO(bassosimone): route this error.
            break;
        }

        if (ev.at("key") == FailureAsnLookupEvent::key) {
            FailureAsnLookupEvent event;
            if (ev.count("failure") <= 0 || !ev.at("failure").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.failure = ev.at("value").at("failure");
            on_failure_asn_lookup(event);
            continue;
        }
        if (ev.at("key") == FailureCcLookupEvent::key) {
            FailureCcLookupEvent event;
            if (ev.count("failure") <= 0 || !ev.at("failure").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.failure = ev.at("value").at("failure");
            on_failure_cc_lookup(event);
            continue;
        }
        if (ev.at("key") == FailureIpLookupEvent::key) {
            FailureIpLookupEvent event;
            if (ev.count("failure") <= 0 || !ev.at("failure").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.failure = ev.at("value").at("failure");
            on_failure_ip_lookup(event);
            continue;
        }
        if (ev.at("key") == FailureMeasurementEvent::key) {
            FailureMeasurementEvent event;
            if (ev.count("failure") <= 0 || !ev.at("failure").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.failure = ev.at("value").at("failure");
            on_failure_measurement(event);
            continue;
        }
        if (ev.at("key") == FailureMeasurementSubmissionEvent::key) {
            FailureMeasurementSubmissionEvent event;
            if (ev.count("failure") <= 0 || !ev.at("failure").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.failure = ev.at("value").at("failure");
            if (ev.count("idx") <= 0 || !ev.at("idx").is_number_integer()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.idx = ev.at("value").at("idx");
            if (ev.count("json_str") <= 0 || !ev.at("json_str").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.json_str = ev.at("value").at("json_str");
            on_failure_measurement_submission(event);
            continue;
        }
        if (ev.at("key") == FailureReportCreateEvent::key) {
            FailureReportCreateEvent event;
            if (ev.count("failure") <= 0 || !ev.at("failure").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.failure = ev.at("value").at("failure");
            on_failure_report_create(event);
            continue;
        }
        if (ev.at("key") == FailureReportCloseEvent::key) {
            FailureReportCloseEvent event;
            if (ev.count("failure") <= 0 || !ev.at("failure").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.failure = ev.at("value").at("failure");
            on_failure_report_close(event);
            continue;
        }
        if (ev.at("key") == FailureResolverLookupEvent::key) {
            FailureResolverLookupEvent event;
            if (ev.count("failure") <= 0 || !ev.at("failure").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.failure = ev.at("value").at("failure");
            on_failure_resolver_lookup(event);
            continue;
        }
        if (ev.at("key") == FailureStartupEvent::key) {
            FailureStartupEvent event;
            if (ev.count("failure") <= 0 || !ev.at("failure").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.failure = ev.at("value").at("failure");
            on_failure_startup(event);
            continue;
        }
        if (ev.at("key") == LogEvent::key) {
            LogEvent event;
            if (ev.count("log_level") <= 0 || !ev.at("log_level").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.log_level = ev.at("value").at("log_level");
            if (ev.count("message") <= 0 || !ev.at("message").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.message = ev.at("value").at("message");
            on_log(event);
            continue;
        }
        if (ev.at("key") == MeasurementEvent::key) {
            MeasurementEvent event;
            if (ev.count("idx") <= 0 || !ev.at("idx").is_number_integer()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.idx = ev.at("value").at("idx");
            if (ev.count("json_str") <= 0 || !ev.at("json_str").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.json_str = ev.at("value").at("json_str");
            on_measurement(event);
            continue;
        }
        if (ev.at("key") == StatusEndEvent::key) {
            StatusEndEvent event;
            if (ev.count("downloaded_kb") <= 0 || !ev.at("downloaded_kb").is_number_float()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.downloaded_kb = ev.at("value").at("downloaded_kb");
            if (ev.count("uploaded_kb") <= 0 || !ev.at("uploaded_kb").is_number_float()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.uploaded_kb = ev.at("value").at("uploaded_kb");
            if (ev.count("failure") <= 0 || !ev.at("failure").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.failure = ev.at("value").at("failure");
            on_status_end(event);
            continue;
        }
        if (ev.at("key") == StatusGeoipLookupEvent::key) {
            StatusGeoipLookupEvent event;
            if (ev.count("probe_ip") <= 0 || !ev.at("probe_ip").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.probe_ip = ev.at("value").at("probe_ip");
            if (ev.count("probe_asn") <= 0 || !ev.at("probe_asn").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.probe_asn = ev.at("value").at("probe_asn");
            if (ev.count("probe_cc") <= 0 || !ev.at("probe_cc").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.probe_cc = ev.at("value").at("probe_cc");
            if (ev.count("probe_network_name") <= 0 || !ev.at("probe_network_name").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.probe_network_name = ev.at("value").at("probe_network_name");
            on_status_geoip_lookup(event);
            continue;
        }
        if (ev.at("key") == StatusProgressEvent::key) {
            StatusProgressEvent event;
            if (ev.count("percentage") <= 0 || !ev.at("percentage").is_number_float()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.percentage = ev.at("value").at("percentage");
            if (ev.count("message") <= 0 || !ev.at("message").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.message = ev.at("value").at("message");
            on_status_progress(event);
            continue;
        }
        if (ev.at("key") == StatusQueuedEvent::key) {
            StatusQueuedEvent event;
            /* No attributes */
            on_status_queued(event);
            continue;
        }
        if (ev.at("key") == StatusMeasurementStartEvent::key) {
            StatusMeasurementStartEvent event;
            if (ev.count("idx") <= 0 || !ev.at("idx").is_number_integer()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.idx = ev.at("value").at("idx");
            if (ev.count("input") <= 0 || !ev.at("input").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.input = ev.at("value").at("input");
            on_status_measurement_start(event);
            continue;
        }
        if (ev.at("key") == StatusMeasurementSubmissionEvent::key) {
            StatusMeasurementSubmissionEvent event;
            if (ev.count("idx") <= 0 || !ev.at("idx").is_number_integer()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.idx = ev.at("value").at("idx");
            on_status_measurement_submission(event);
            continue;
        }
        if (ev.at("key") == StatusMeasurementDoneEvent::key) {
            StatusMeasurementDoneEvent event;
            if (ev.count("idx") <= 0 || !ev.at("idx").is_number_integer()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.idx = ev.at("value").at("idx");
            on_status_measurement_done(event);
            continue;
        }
        if (ev.at("key") == StatusReportCloseEvent::key) {
            StatusReportCloseEvent event;
            if (ev.count("report_id") <= 0 || !ev.at("report_id").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.report_id = ev.at("value").at("report_id");
            on_status_report_close(event);
            continue;
        }
        if (ev.at("key") == StatusReportCreateEvent::key) {
            StatusReportCreateEvent event;
            if (ev.count("report_id") <= 0 || !ev.at("report_id").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.report_id = ev.at("value").at("report_id");
            on_status_report_create(event);
            continue;
        }
        if (ev.at("key") == StatusResolverLookupEvent::key) {
            StatusResolverLookupEvent event;
            if (ev.count("ip_address") <= 0 || !ev.at("ip_address").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.ip_address = ev.at("value").at("ip_address");
            on_status_resolver_lookup(event);
            continue;
        }
        if (ev.at("key") == StatusStartedEvent::key) {
            StatusStartedEvent event;
            /* No attributes */
            on_status_started(event);
            continue;
        }
        if (ev.at("key") == StatusUpdatePerformanceEvent::key) {
            StatusUpdatePerformanceEvent event;
            if (ev.count("direction") <= 0 || !ev.at("direction").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.direction = ev.at("value").at("direction");
            if (ev.count("elapsed") <= 0 || !ev.at("elapsed").is_number_float()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.elapsed = ev.at("value").at("elapsed");
            if (ev.count("num_streams") <= 0 || !ev.at("num_streams").is_number_integer()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.num_streams = ev.at("value").at("num_streams");
            if (ev.count("speed_kbps") <= 0 || !ev.at("speed_kbps").is_number_float()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.speed_kbps = ev.at("value").at("speed_kbps");
            on_status_update_performance(event);
            continue;
        }
        if (ev.at("key") == StatusUpdateWebsitesEvent::key) {
            StatusUpdateWebsitesEvent event;
            if (ev.count("url") <= 0 || !ev.at("url").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.url = ev.at("value").at("url");
            if (ev.count("status") <= 0 || !ev.at("status").is_string()) {
                // TODO(bassosimone): route this error.
                break;
            }
            event.status = ev.at("value").at("status");
            on_status_update_websites(event);
            continue;
        }
        if (ev.at("key") == TaskTerminatedEvent::key) {
            TaskTerminatedEvent event;
            /* No attributes */
            on_task_terminated(event);
            continue;
        }

#ifdef MK_NETTEST_TRACE
        std::clog << "NETTEST: unhandled event: " << str << std::endl;
#endif
        // TODO(bassosimone): route this error.
        break;
    }

    // Implementation note: if we leave this function early because of any
    // error, we also want to stop the nettest as soon as possible.
    if (!mk_task_is_done(impl_->task.get())) {
        mk_task_interrupt(impl_->task.get());
    }
}

#endif // !MK_NETTEST_NO_INLINE_IMPL && !SWIG
} // namespace nettest
} // namespace mk
#endif // MEASUREMENT_KIT_NETTEST_HPP
