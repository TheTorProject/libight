// Auto-generated by ./script/gen/cxx14/all; don't edit
#ifndef MEASUREMENT_KIT_CXX14_ALL_HPP
#define MEASUREMENT_KIT_CXX14_ALL_HPP

#include <assert.h>
#include <stdint.h>

#include <functional>
#include <string>
#include <thread>
#include <utility>
#include <vector>

#include <measurement_kit/common/nlohmann/json.hpp>
#include <measurement_kit/ffi.h>

namespace mk {
namespace cxx14 {

/// C++ representation of 'failure.asn_lookup' event
class FailureAsnLookup {
  public:
    std::string failure;
};

/// C++ representation of 'failure.cc_lookup' event
class FailureCcLookup {
  public:
    std::string failure;
};

/// C++ representation of 'failure.ip_lookup' event
class FailureIpLookup {
  public:
    std::string failure;
};

/// C++ representation of 'failure.measurement' event
class FailureMeasurement {
  public:
    std::string failure;
};

/// C++ representation of 'failure.measurement_submission' event
class FailureMeasurementSubmission {
  public:
    std::string failure;
    std::string json_str;
    int64_t idx;
};

/// C++ representation of 'failure.report_close' event
class FailureReportClose {
  public:
    std::string failure;
};

/// C++ representation of 'failure.report_create' event
class FailureReportCreate {
  public:
    std::string failure;
};

/// C++ representation of 'failure.resolver_lookup' event
class FailureResolverLookup {
  public:
    std::string failure;
};

/// C++ representation of 'failure.startup' event
class FailureStartup {
  public:
    std::string failure;
};

/// C++ representation of 'log' event
class Log {
  public:
    std::string message;
    std::string log_level;
};

/// C++ representation of 'measurement' event
class Measurement {
  public:
    std::string json_str;
    int64_t idx;
};

/// C++ representation of 'status.end' event
class StatusEnd {
  public:
    std::string failure;
    double uploaded_kb;
    double downloaded_kb;
};

/// C++ representation of 'status.geoip_lookup' event
class StatusGeoipLookup {
  public:
    std::string probe_ip;
    std::string probe_network_name;
    std::string probe_asn;
    std::string probe_cc;
};

/// C++ representation of 'status.measurement_done' event
class StatusMeasurementDone {
  public:
    int64_t idx;
};

/// C++ representation of 'status.measurement_start' event
class StatusMeasurementStart {
  public:
    std::string input;
    int64_t idx;
};

/// C++ representation of 'status.measurement_submission' event
class StatusMeasurementSubmission {
  public:
    int64_t idx;
};

/// C++ representation of 'status.progress' event
class StatusProgress {
  public:
    double percentage;
    std::string message;
};

/// C++ representation of 'status.queued' event
class StatusQueued {
  public:
};

/// C++ representation of 'status.report_close' event
class StatusReportClose {
  public:
    std::string report_id;
};

/// C++ representation of 'status.report_create' event
class StatusReportCreate {
  public:
    std::string report_id;
};

/// C++ representation of 'status.resolver_lookup' event
class StatusResolverLookup {
  public:
    std::string resolver_ip;
};

/// C++ representation of 'status.started' event
class StatusStarted {
  public:
};

/// C++ representation of 'status.terminated' event
class StatusTerminated {
  public:
};

/// C++ representation of 'status.update.performance' event
class StatusUpdatePerformance {
  public:
    std::string direction;
    int64_t num_streams;
    double speed_kbps;
    double elapsed;
};

/// C++ representation of 'status.update.websites' event
class StatusUpdateWebsites {
  public:
    std::string url;
    std::string status;
};

/// Callback taking FailureAsnLookup as unique argument
using FailureAsnLookupCallback = std::function<void(FailureAsnLookup)>;

/// Callback taking FailureCcLookup as unique argument
using FailureCcLookupCallback = std::function<void(FailureCcLookup)>;

/// Callback taking FailureIpLookup as unique argument
using FailureIpLookupCallback = std::function<void(FailureIpLookup)>;

/// Callback taking FailureMeasurement as unique argument
using FailureMeasurementCallback = std::function<void(FailureMeasurement)>;

/// Callback taking FailureMeasurementSubmission as unique argument
using FailureMeasurementSubmissionCallback = std::function<void(FailureMeasurementSubmission)>;

/// Callback taking FailureReportClose as unique argument
using FailureReportCloseCallback = std::function<void(FailureReportClose)>;

/// Callback taking FailureReportCreate as unique argument
using FailureReportCreateCallback = std::function<void(FailureReportCreate)>;

/// Callback taking FailureResolverLookup as unique argument
using FailureResolverLookupCallback = std::function<void(FailureResolverLookup)>;

/// Callback taking FailureStartup as unique argument
using FailureStartupCallback = std::function<void(FailureStartup)>;

/// Callback taking Log as unique argument
using LogCallback = std::function<void(Log)>;

/// Callback taking Measurement as unique argument
using MeasurementCallback = std::function<void(Measurement)>;

/// Callback taking StatusEnd as unique argument
using StatusEndCallback = std::function<void(StatusEnd)>;

/// Callback taking StatusGeoipLookup as unique argument
using StatusGeoipLookupCallback = std::function<void(StatusGeoipLookup)>;

/// Callback taking StatusMeasurementDone as unique argument
using StatusMeasurementDoneCallback = std::function<void(StatusMeasurementDone)>;

/// Callback taking StatusMeasurementStart as unique argument
using StatusMeasurementStartCallback = std::function<void(StatusMeasurementStart)>;

/// Callback taking StatusMeasurementSubmission as unique argument
using StatusMeasurementSubmissionCallback = std::function<void(StatusMeasurementSubmission)>;

/// Callback taking StatusProgress as unique argument
using StatusProgressCallback = std::function<void(StatusProgress)>;

/// Callback taking StatusQueued as unique argument
using StatusQueuedCallback = std::function<void(StatusQueued)>;

/// Callback taking StatusReportClose as unique argument
using StatusReportCloseCallback = std::function<void(StatusReportClose)>;

/// Callback taking StatusReportCreate as unique argument
using StatusReportCreateCallback = std::function<void(StatusReportCreate)>;

/// Callback taking StatusResolverLookup as unique argument
using StatusResolverLookupCallback = std::function<void(StatusResolverLookup)>;

/// Callback taking StatusStarted as unique argument
using StatusStartedCallback = std::function<void(StatusStarted)>;

/// Callback taking StatusTerminated as unique argument
using StatusTerminatedCallback = std::function<void(StatusTerminated)>;

/// Callback taking StatusUpdatePerformance as unique argument
using StatusUpdatePerformanceCallback = std::function<void(StatusUpdatePerformance)>;

/// Callback taking StatusUpdateWebsites as unique argument
using StatusUpdateWebsitesCallback = std::function<void(StatusUpdateWebsites)>;

/// Info on a generic task
class TaskInfo {
  public:
    /// 'annotations' field of settings
    nlohmann::json annotations;

    /// Allows to set annotation using a fluent style
    TaskInfo &set_annotation(const std::string &k, double v) noexcept {
        annotations[k] = v;
        return *this;
    }

    /// Allows to set annotation using a fluent style
    TaskInfo &set_annotation(const std::string &k, int64_t v) noexcept {
        annotations[k] = v;
        return *this;
    }

    /// Allows to set annotation using a fluent style
    TaskInfo &set_annotation(const std::string &k, const std::string &v) noexcept {
        annotations[k] = v;
        return *this;
    }

    /// 'disabled_events' field of settings
    std::vector<std::string> disabled_events;

    /// Allows to append to 'disabled_events' using a fluent style
    TaskInfo &add_disabled_event(const std::string &s) noexcept {
        disabled_events.push_back(s);
        return *this;
    }

    /// 'input_filepaths' field of settings
    std::vector<std::string> input_filepaths;

    /// Allows to append to 'input_filepaths' using a fluent style
    TaskInfo &add_input_filepath(const std::string &s) noexcept {
        input_filepaths.push_back(s);
        return *this;
    }

    /// 'inputs' field of settings
    std::vector<std::string> inputs;

    /// Allows to append to 'inputs' using a fluent style
    TaskInfo &add_input(const std::string &s) noexcept {
        inputs.push_back(s);
        return *this;
    }

    /// 'log_filepath' field of settings
    std::string log_filepath;

    /// Allows to set 'log_filepath' using a fluent style
    TaskInfo &set_log_filepath(const std::string &s) noexcept {
        log_filepath = s;
        return *this;
    }

    /// 'log_level' field of settings
    std::string log_level;

    /// Allows to set 'log_level' using a fluent style
    TaskInfo &set_log_level(const std::string &s) noexcept {
        log_level = s;
        return *this;
    }

    /// 'name' field of settings
    std::string name;

    /// Allows to set 'name' using a fluent style
    TaskInfo &set_name(const std::string &s) noexcept {
        name = s;
        return *this;
    }

    /// 'options' field of settings
    nlohmann::json options;

    /// Allows to set option using a fluent style
    TaskInfo &set_option(const std::string &k, double v) noexcept {
        options[k] = v;
        return *this;
    }

    /// Allows to set option using a fluent style
    TaskInfo &set_option(const std::string &k, int64_t v) noexcept {
        options[k] = v;
        return *this;
    }

    /// Allows to set option using a fluent style
    TaskInfo &set_option(const std::string &k, const std::string &v) noexcept {
        options[k] = v;
        return *this;
    }

    /// Allows to set 'bouncer_base_url' option using a fluent style
    TaskInfo &set_bouncer_base_url_option(const std::string &v) noexcept {
        options["bouncer_base_url"] = v;
        return *this;
    }

    /// Allows to set 'collector_base_url' option using a fluent style
    TaskInfo &set_collector_base_url_option(const std::string &v) noexcept {
        options["collector_base_url"] = v;
        return *this;
    }

    /// Allows to set 'dns/engine' option using a fluent style
    TaskInfo &set_dns_engine_option(const std::string &v) noexcept {
        options["dns/engine"] = v;
        return *this;
    }

    /// Allows to set 'dns/nameserver' option using a fluent style
    TaskInfo &set_dns_nameserver_option(const std::string &v) noexcept {
        options["dns/nameserver"] = v;
        return *this;
    }

    /// Allows to set 'geoip_asn_path' option using a fluent style
    TaskInfo &set_geoip_asn_path_option(const std::string &v) noexcept {
        options["geoip_asn_path"] = v;
        return *this;
    }

    /// Allows to set 'geoip_country_path' option using a fluent style
    TaskInfo &set_geoip_country_path_option(const std::string &v) noexcept {
        options["geoip_country_path"] = v;
        return *this;
    }

    /// Allows to set 'ignore_bouncer_error' option using a fluent style
    TaskInfo &set_ignore_bouncer_error_option(int64_t v) noexcept {
        options["ignore_bouncer_error"] = v;
        return *this;
    }

    /// Allows to set 'ignore_open_report_error' option using a fluent style
    TaskInfo &set_ignore_open_report_error_option(int64_t v) noexcept {
        options["ignore_open_report_error"] = v;
        return *this;
    }

    /// Allows to set 'max_runtime' option using a fluent style
    TaskInfo &set_max_runtime_option(double v) noexcept {
        options["max_runtime"] = v;
        return *this;
    }

    /// Allows to set 'net/ca_bundle_path' option using a fluent style
    TaskInfo &set_net_ca_bundle_path_option(const std::string &v) noexcept {
        options["net/ca_bundle_path"] = v;
        return *this;
    }

    /// Allows to set 'net/timeout' option using a fluent style
    TaskInfo &set_net_timeout_option(double v) noexcept {
        options["net/timeout"] = v;
        return *this;
    }

    /// Allows to set 'no_asn_lookup' option using a fluent style
    TaskInfo &set_no_asn_lookup_option(int64_t v) noexcept {
        options["no_asn_lookup"] = v;
        return *this;
    }

    /// Allows to set 'no_bouncer' option using a fluent style
    TaskInfo &set_no_bouncer_option(int64_t v) noexcept {
        options["no_bouncer"] = v;
        return *this;
    }

    /// Allows to set 'no_cc_lookup' option using a fluent style
    TaskInfo &set_no_cc_lookup_option(int64_t v) noexcept {
        options["no_cc_lookup"] = v;
        return *this;
    }

    /// Allows to set 'no_collector' option using a fluent style
    TaskInfo &set_no_collector_option(int64_t v) noexcept {
        options["no_collector"] = v;
        return *this;
    }

    /// Allows to set 'no_file_report' option using a fluent style
    TaskInfo &set_no_file_report_option(int64_t v) noexcept {
        options["no_file_report"] = v;
        return *this;
    }

    /// Allows to set 'no_ip_lookup' option using a fluent style
    TaskInfo &set_no_ip_lookup_option(int64_t v) noexcept {
        options["no_ip_lookup"] = v;
        return *this;
    }

    /// Allows to set 'no_resolver_lookup' option using a fluent style
    TaskInfo &set_no_resolver_lookup_option(int64_t v) noexcept {
        options["no_resolver_lookup"] = v;
        return *this;
    }

    /// Allows to set 'probe_asn' option using a fluent style
    TaskInfo &set_probe_asn_option(const std::string &v) noexcept {
        options["probe_asn"] = v;
        return *this;
    }

    /// Allows to set 'probe_cc' option using a fluent style
    TaskInfo &set_probe_cc_option(const std::string &v) noexcept {
        options["probe_cc"] = v;
        return *this;
    }

    /// Allows to set 'probe_ip' option using a fluent style
    TaskInfo &set_probe_ip_option(const std::string &v) noexcept {
        options["probe_ip"] = v;
        return *this;
    }

    /// Allows to set 'randomize_input' option using a fluent style
    TaskInfo &set_randomize_input_option(int64_t v) noexcept {
        options["randomize_input"] = v;
        return *this;
    }

    /// Allows to set 'save_real_probe_asn' option using a fluent style
    TaskInfo &set_save_real_probe_asn_option(int64_t v) noexcept {
        options["save_real_probe_asn"] = v;
        return *this;
    }

    /// Allows to set 'save_real_probe_cc' option using a fluent style
    TaskInfo &set_save_real_probe_cc_option(int64_t v) noexcept {
        options["save_real_probe_cc"] = v;
        return *this;
    }

    /// Allows to set 'save_real_probe_ip' option using a fluent style
    TaskInfo &set_save_real_probe_ip_option(int64_t v) noexcept {
        options["save_real_probe_ip"] = v;
        return *this;
    }

    /// Allows to set 'save_real_resolver_ip' option using a fluent style
    TaskInfo &set_save_real_resolver_ip_option(int64_t v) noexcept {
        options["save_real_resolver_ip"] = v;
        return *this;
    }

    /// Allows to set 'software_name' option using a fluent style
    TaskInfo &set_software_name_option(const std::string &v) noexcept {
        options["software_name"] = v;
        return *this;
    }

    /// Allows to set 'software_version' option using a fluent style
    TaskInfo &set_software_version_option(const std::string &v) noexcept {
        options["software_version"] = v;
        return *this;
    }

    /// 'output_filepath' field of settings
    std::string output_filepath;

    /// Allows to set 'output_filepath' using a fluent style
    TaskInfo &set_output_filepath(const std::string &s) noexcept {
        output_filepath = s;
        return *this;
    }

    /// Callbacks for 'failure.asn_lookup' event
    std::vector<FailureAsnLookupCallback> failure_asn_lookup_cbs;

    /// Allows to add callback for 'failure.asn_lookup' event using a fluent style
    TaskInfo &on_failure_asn_lookup(FailureAsnLookupCallback &&cb) noexcept {
        failure_asn_lookup_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'failure.cc_lookup' event
    std::vector<FailureCcLookupCallback> failure_cc_lookup_cbs;

    /// Allows to add callback for 'failure.cc_lookup' event using a fluent style
    TaskInfo &on_failure_cc_lookup(FailureCcLookupCallback &&cb) noexcept {
        failure_cc_lookup_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'failure.ip_lookup' event
    std::vector<FailureIpLookupCallback> failure_ip_lookup_cbs;

    /// Allows to add callback for 'failure.ip_lookup' event using a fluent style
    TaskInfo &on_failure_ip_lookup(FailureIpLookupCallback &&cb) noexcept {
        failure_ip_lookup_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'failure.measurement' event
    std::vector<FailureMeasurementCallback> failure_measurement_cbs;

    /// Allows to add callback for 'failure.measurement' event using a fluent style
    TaskInfo &on_failure_measurement(FailureMeasurementCallback &&cb) noexcept {
        failure_measurement_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'failure.measurement_submission' event
    std::vector<FailureMeasurementSubmissionCallback> failure_measurement_submission_cbs;

    /// Allows to add callback for 'failure.measurement_submission' event using a fluent style
    TaskInfo &on_failure_measurement_submission(FailureMeasurementSubmissionCallback &&cb) noexcept {
        failure_measurement_submission_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'failure.report_close' event
    std::vector<FailureReportCloseCallback> failure_report_close_cbs;

    /// Allows to add callback for 'failure.report_close' event using a fluent style
    TaskInfo &on_failure_report_close(FailureReportCloseCallback &&cb) noexcept {
        failure_report_close_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'failure.report_create' event
    std::vector<FailureReportCreateCallback> failure_report_create_cbs;

    /// Allows to add callback for 'failure.report_create' event using a fluent style
    TaskInfo &on_failure_report_create(FailureReportCreateCallback &&cb) noexcept {
        failure_report_create_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'failure.resolver_lookup' event
    std::vector<FailureResolverLookupCallback> failure_resolver_lookup_cbs;

    /// Allows to add callback for 'failure.resolver_lookup' event using a fluent style
    TaskInfo &on_failure_resolver_lookup(FailureResolverLookupCallback &&cb) noexcept {
        failure_resolver_lookup_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'failure.startup' event
    std::vector<FailureStartupCallback> failure_startup_cbs;

    /// Allows to add callback for 'failure.startup' event using a fluent style
    TaskInfo &on_failure_startup(FailureStartupCallback &&cb) noexcept {
        failure_startup_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'log' event
    std::vector<LogCallback> log_cbs;

    /// Allows to add callback for 'log' event using a fluent style
    TaskInfo &on_log(LogCallback &&cb) noexcept {
        log_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'measurement' event
    std::vector<MeasurementCallback> measurement_cbs;

    /// Allows to add callback for 'measurement' event using a fluent style
    TaskInfo &on_measurement(MeasurementCallback &&cb) noexcept {
        measurement_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'status.end' event
    std::vector<StatusEndCallback> status_end_cbs;

    /// Allows to add callback for 'status.end' event using a fluent style
    TaskInfo &on_status_end(StatusEndCallback &&cb) noexcept {
        status_end_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'status.geoip_lookup' event
    std::vector<StatusGeoipLookupCallback> status_geoip_lookup_cbs;

    /// Allows to add callback for 'status.geoip_lookup' event using a fluent style
    TaskInfo &on_status_geoip_lookup(StatusGeoipLookupCallback &&cb) noexcept {
        status_geoip_lookup_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'status.measurement_done' event
    std::vector<StatusMeasurementDoneCallback> status_measurement_done_cbs;

    /// Allows to add callback for 'status.measurement_done' event using a fluent style
    TaskInfo &on_status_measurement_done(StatusMeasurementDoneCallback &&cb) noexcept {
        status_measurement_done_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'status.measurement_start' event
    std::vector<StatusMeasurementStartCallback> status_measurement_start_cbs;

    /// Allows to add callback for 'status.measurement_start' event using a fluent style
    TaskInfo &on_status_measurement_start(StatusMeasurementStartCallback &&cb) noexcept {
        status_measurement_start_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'status.measurement_submission' event
    std::vector<StatusMeasurementSubmissionCallback> status_measurement_submission_cbs;

    /// Allows to add callback for 'status.measurement_submission' event using a fluent style
    TaskInfo &on_status_measurement_submission(StatusMeasurementSubmissionCallback &&cb) noexcept {
        status_measurement_submission_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'status.progress' event
    std::vector<StatusProgressCallback> status_progress_cbs;

    /// Allows to add callback for 'status.progress' event using a fluent style
    TaskInfo &on_status_progress(StatusProgressCallback &&cb) noexcept {
        status_progress_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'status.queued' event
    std::vector<StatusQueuedCallback> status_queued_cbs;

    /// Allows to add callback for 'status.queued' event using a fluent style
    TaskInfo &on_status_queued(StatusQueuedCallback &&cb) noexcept {
        status_queued_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'status.report_close' event
    std::vector<StatusReportCloseCallback> status_report_close_cbs;

    /// Allows to add callback for 'status.report_close' event using a fluent style
    TaskInfo &on_status_report_close(StatusReportCloseCallback &&cb) noexcept {
        status_report_close_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'status.report_create' event
    std::vector<StatusReportCreateCallback> status_report_create_cbs;

    /// Allows to add callback for 'status.report_create' event using a fluent style
    TaskInfo &on_status_report_create(StatusReportCreateCallback &&cb) noexcept {
        status_report_create_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'status.resolver_lookup' event
    std::vector<StatusResolverLookupCallback> status_resolver_lookup_cbs;

    /// Allows to add callback for 'status.resolver_lookup' event using a fluent style
    TaskInfo &on_status_resolver_lookup(StatusResolverLookupCallback &&cb) noexcept {
        status_resolver_lookup_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'status.started' event
    std::vector<StatusStartedCallback> status_started_cbs;

    /// Allows to add callback for 'status.started' event using a fluent style
    TaskInfo &on_status_started(StatusStartedCallback &&cb) noexcept {
        status_started_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'status.terminated' event
    std::vector<StatusTerminatedCallback> status_terminated_cbs;

    /// Allows to add callback for 'status.terminated' event using a fluent style
    TaskInfo &on_status_terminated(StatusTerminatedCallback &&cb) noexcept {
        status_terminated_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'status.update.performance' event
    std::vector<StatusUpdatePerformanceCallback> status_update_performance_cbs;

    /// Allows to add callback for 'status.update.performance' event using a fluent style
    TaskInfo &on_status_update_performance(StatusUpdatePerformanceCallback &&cb) noexcept {
        status_update_performance_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Callbacks for 'status.update.websites' event
    std::vector<StatusUpdateWebsitesCallback> status_update_websites_cbs;

    /// Allows to add callback for 'status.update.websites' event using a fluent style
    TaskInfo &on_status_update_websites(StatusUpdateWebsitesCallback &&cb) noexcept {
        status_update_websites_cbs.push_back(std::move(cb));
        return *this;
    }

    /// Factory method for creating a 'CaptivePortal' task
    static TaskInfo CaptivePortal() noexcept {
        TaskInfo info;
        info.name = "CaptivePortal";
        return info;
    };

    /// Factory method for creating a 'Dash' task
    static TaskInfo Dash() noexcept {
        TaskInfo info;
        info.name = "Dash";
        return info;
    };

    /// Factory method for creating a 'DnsInjection' task
    static TaskInfo DnsInjection() noexcept {
        TaskInfo info;
        info.name = "DnsInjection";
        return info;
    };

    /// Factory method for creating a 'FacebookMessenger' task
    static TaskInfo FacebookMessenger() noexcept {
        TaskInfo info;
        info.name = "FacebookMessenger";
        return info;
    };

    /// Factory method for creating a 'HttpHeaderFieldManipulation' task
    static TaskInfo HttpHeaderFieldManipulation() noexcept {
        TaskInfo info;
        info.name = "HttpHeaderFieldManipulation";
        return info;
    };

    /// Factory method for creating a 'HttpInvalidRequestLine' task
    static TaskInfo HttpInvalidRequestLine() noexcept {
        TaskInfo info;
        info.name = "HttpInvalidRequestLine";
        return info;
    };

    /// Factory method for creating a 'MeekFrontedRequests' task
    static TaskInfo MeekFrontedRequests() noexcept {
        TaskInfo info;
        info.name = "MeekFrontedRequests";
        return info;
    };

    /// Factory method for creating a 'MultiNdt' task
    static TaskInfo MultiNdt() noexcept {
        TaskInfo info;
        info.name = "MultiNdt";
        return info;
    };

    /// Factory method for creating a 'Ndt' task
    static TaskInfo Ndt() noexcept {
        TaskInfo info;
        info.name = "Ndt";
        return info;
    };

    /// Factory method for creating a 'TcpConnect' task
    static TaskInfo TcpConnect() noexcept {
        TaskInfo info;
        info.name = "TcpConnect";
        return info;
    };

    /// Factory method for creating a 'Telegram' task
    static TaskInfo Telegram() noexcept {
        TaskInfo info;
        info.name = "Telegram";
        return info;
    };

    /// Factory method for creating a 'WebConnectivity' task
    static TaskInfo WebConnectivity() noexcept {
        TaskInfo info;
        info.name = "WebConnectivity";
        return info;
    };

    /// Factory method for creating a 'Whatsapp' task
    static TaskInfo Whatsapp() noexcept {
        TaskInfo info;
        info.name = "Whatsapp";
        return info;
    };
};

/// Exceptions emitted by JSON library
#if NLOHMANN_JSON_VERSION_MAJOR >= 3
using NlohmannJsonException = nlohmann::json::exception;
#else
using NlohmannJsonException = std::exception;
#endif

/// Runs a task
class TaskRunner {
  public:
    /// Runs the specified task in the current thread
    bool run(TaskInfo &&info) const noexcept {
        nlohmann::json doc;
        doc["annotations"] = info.annotations;
        doc["disabled_events"] = info.disabled_events;
        doc["input_filepaths"] = info.input_filepaths;
        doc["inputs"] = info.inputs;
        doc["log_filepath"] = info.log_filepath;
        doc["log_level"] = info.log_level;
        doc["name"] = info.name;
        doc["options"] = info.options;
        doc["output_filepath"] = info.output_filepath;
        std::string settings;
        try {
            settings = doc.dump();
        } catch (const NlohmannJsonException &) {
            return false;
        }
        auto ptask = mk_task_start(settings.c_str());
        if (!ptask) {
            return false;
        }
        auto rv = true;
        while (rv && !mk_task_is_done(ptask)) {
            auto pevent = mk_task_wait_for_next_event(ptask);
            if (!pevent) {
                rv = false;
                break;
            }
            auto pstr = mk_event_serialize(pevent);
            if (!pstr) {
                mk_event_destroy(pevent);
                assert(false);
                rv = false;
                break;
            }
            nlohmann::json event;
            try {
                event = nlohmann::json::parse(pstr);
            } catch (const NlohmannJsonException &) {
                mk_event_destroy(pevent);
                assert(false);
                rv = false;
                break;
            }
            mk_event_destroy(pevent);
            rv = process_event(info, event);
        }
        if (!rv) {
            mk_task_interrupt(ptask);
        }
        mk_task_destroy(ptask);
        return rv;
    }

    bool process_event(const TaskInfo &info, const nlohmann::json &event) const noexcept {
       if (!event.is_object()) {
           return false;
       }
       if (event.count("key") <= 0) {
           return false;
       }
       if (!event.at("key").is_string()) {
           return false;
       }
       if (!event.count("value")) {
           return false;
       }
       if (!event.at("value").is_object()) {
           return false;
       }
       const std::string &key = event.at("key");
       const nlohmann::json &value = event.at("value");

       if (key == "failure.asn_lookup") {
           FailureAsnLookup data;
           if (value.count("failure") <= 0) {
               return false;
           }
           try {
               data.failure = value.at("failure");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           for (auto &cb : info.failure_asn_lookup_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "failure.cc_lookup") {
           FailureCcLookup data;
           if (value.count("failure") <= 0) {
               return false;
           }
           try {
               data.failure = value.at("failure");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           for (auto &cb : info.failure_cc_lookup_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "failure.ip_lookup") {
           FailureIpLookup data;
           if (value.count("failure") <= 0) {
               return false;
           }
           try {
               data.failure = value.at("failure");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           for (auto &cb : info.failure_ip_lookup_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "failure.measurement") {
           FailureMeasurement data;
           if (value.count("failure") <= 0) {
               return false;
           }
           try {
               data.failure = value.at("failure");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           for (auto &cb : info.failure_measurement_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "failure.measurement_submission") {
           FailureMeasurementSubmission data;
           if (value.count("failure") <= 0) {
               return false;
           }
           try {
               data.failure = value.at("failure");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           if (value.count("json_str") <= 0) {
               return false;
           }
           try {
               data.json_str = value.at("json_str");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           if (value.count("idx") <= 0) {
               return false;
           }
           try {
               data.idx = value.at("idx");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           for (auto &cb : info.failure_measurement_submission_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "failure.report_close") {
           FailureReportClose data;
           if (value.count("failure") <= 0) {
               return false;
           }
           try {
               data.failure = value.at("failure");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           for (auto &cb : info.failure_report_close_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "failure.report_create") {
           FailureReportCreate data;
           if (value.count("failure") <= 0) {
               return false;
           }
           try {
               data.failure = value.at("failure");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           for (auto &cb : info.failure_report_create_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "failure.resolver_lookup") {
           FailureResolverLookup data;
           if (value.count("failure") <= 0) {
               return false;
           }
           try {
               data.failure = value.at("failure");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           for (auto &cb : info.failure_resolver_lookup_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "failure.startup") {
           FailureStartup data;
           if (value.count("failure") <= 0) {
               return false;
           }
           try {
               data.failure = value.at("failure");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           for (auto &cb : info.failure_startup_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "log") {
           Log data;
           if (value.count("message") <= 0) {
               return false;
           }
           try {
               data.message = value.at("message");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           if (value.count("log_level") <= 0) {
               return false;
           }
           try {
               data.log_level = value.at("log_level");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           for (auto &cb : info.log_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "measurement") {
           Measurement data;
           if (value.count("json_str") <= 0) {
               return false;
           }
           try {
               data.json_str = value.at("json_str");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           if (value.count("idx") <= 0) {
               return false;
           }
           try {
               data.idx = value.at("idx");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           for (auto &cb : info.measurement_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "status.end") {
           StatusEnd data;
           if (value.count("failure") <= 0) {
               return false;
           }
           try {
               data.failure = value.at("failure");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           if (value.count("uploaded_kb") <= 0) {
               return false;
           }
           try {
               data.uploaded_kb = value.at("uploaded_kb");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           if (value.count("downloaded_kb") <= 0) {
               return false;
           }
           try {
               data.downloaded_kb = value.at("downloaded_kb");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           for (auto &cb : info.status_end_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "status.geoip_lookup") {
           StatusGeoipLookup data;
           if (value.count("probe_ip") <= 0) {
               return false;
           }
           try {
               data.probe_ip = value.at("probe_ip");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           if (value.count("probe_network_name") <= 0) {
               return false;
           }
           try {
               data.probe_network_name = value.at("probe_network_name");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           if (value.count("probe_asn") <= 0) {
               return false;
           }
           try {
               data.probe_asn = value.at("probe_asn");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           if (value.count("probe_cc") <= 0) {
               return false;
           }
           try {
               data.probe_cc = value.at("probe_cc");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           for (auto &cb : info.status_geoip_lookup_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "status.measurement_done") {
           StatusMeasurementDone data;
           if (value.count("idx") <= 0) {
               return false;
           }
           try {
               data.idx = value.at("idx");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           for (auto &cb : info.status_measurement_done_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "status.measurement_start") {
           StatusMeasurementStart data;
           if (value.count("input") <= 0) {
               return false;
           }
           try {
               data.input = value.at("input");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           if (value.count("idx") <= 0) {
               return false;
           }
           try {
               data.idx = value.at("idx");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           for (auto &cb : info.status_measurement_start_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "status.measurement_submission") {
           StatusMeasurementSubmission data;
           if (value.count("idx") <= 0) {
               return false;
           }
           try {
               data.idx = value.at("idx");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           for (auto &cb : info.status_measurement_submission_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "status.progress") {
           StatusProgress data;
           if (value.count("percentage") <= 0) {
               return false;
           }
           try {
               data.percentage = value.at("percentage");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           if (value.count("message") <= 0) {
               return false;
           }
           try {
               data.message = value.at("message");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           for (auto &cb : info.status_progress_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "status.queued") {
           StatusQueued data;
           for (auto &cb : info.status_queued_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "status.report_close") {
           StatusReportClose data;
           if (value.count("report_id") <= 0) {
               return false;
           }
           try {
               data.report_id = value.at("report_id");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           for (auto &cb : info.status_report_close_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "status.report_create") {
           StatusReportCreate data;
           if (value.count("report_id") <= 0) {
               return false;
           }
           try {
               data.report_id = value.at("report_id");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           for (auto &cb : info.status_report_create_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "status.resolver_lookup") {
           StatusResolverLookup data;
           if (value.count("resolver_ip") <= 0) {
               return false;
           }
           try {
               data.resolver_ip = value.at("resolver_ip");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           for (auto &cb : info.status_resolver_lookup_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "status.started") {
           StatusStarted data;
           for (auto &cb : info.status_started_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "status.terminated") {
           StatusTerminated data;
           for (auto &cb : info.status_terminated_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "status.update.performance") {
           StatusUpdatePerformance data;
           if (value.count("direction") <= 0) {
               return false;
           }
           try {
               data.direction = value.at("direction");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           if (value.count("num_streams") <= 0) {
               return false;
           }
           try {
               data.num_streams = value.at("num_streams");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           if (value.count("speed_kbps") <= 0) {
               return false;
           }
           try {
               data.speed_kbps = value.at("speed_kbps");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           if (value.count("elapsed") <= 0) {
               return false;
           }
           try {
               data.elapsed = value.at("elapsed");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           for (auto &cb : info.status_update_performance_cbs) {
               cb(data);
           }
           return true;
       }

       if (key == "status.update.websites") {
           StatusUpdateWebsites data;
           if (value.count("url") <= 0) {
               return false;
           }
           try {
               data.url = value.at("url");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           if (value.count("status") <= 0) {
               return false;
           }
           try {
               data.status = value.at("status");
           } catch (const NlohmannJsonException &exc) {
               return false;
           }
           for (auto &cb : info.status_update_websites_cbs) {
               cb(data);
           }
           return true;
       }

       return false;
    }

    /// Start a task in a background thread
    void start(TaskInfo &&info, std::function<void()> &&cb) const noexcept {
        std::thread thread{[this, info = std::move(info), cb = std::move(cb)]() mutable noexcept {
            run(std::move(info));
            cb();
        }};
    }

    /// Factory to obtain the global runner
    static const TaskRunner &global() noexcept {
        static TaskRunner runner;
        return runner;
    }
};
} // namespace cxx14
} // namespace mk
#endif // MEASUREMENT_KIT_CXX14_ALL_HPP
