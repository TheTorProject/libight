// Part of Measurement Kit <https://measurement-kit.github.io/>.
// Measurement Kit is free software under the BSD license. See AUTHORS
// and LICENSE for more information on the copying conditions.

/*-
 *  __      __  _____ __________  _______  .___ _______    ________
 * /  \    /  \/  _  \\______   \ \      \ |   |\      \  /  _____/
 * \   \/\/   /  /_\  \|       _/ /   |   \|   |/   |   \/   \  ___
 *  \        /    |    \    |   \/    |    \   /    |    \    \_\  \
 *   \__/\  /\____|__  /____|_  /\____|__  /___\____|__  /\______  /
 *        \/         \/       \/         \/            \/        \/
 *
 * Autogenerated by `./script/autoapi/autoapi`. DO NOT EDIT!!!
 */

#include "src/libmeasurement_kit/engine.hpp"

#include <assert.h>
#include <stdint.h>

#include <algorithm>
#include <atomic>
#include <condition_variable>
#include <deque>
#include <exception>
#include <future>
#include <memory>
#include <mutex>
#include <set>
#include <sstream>
#include <string>
#include <thread>
#include <tuple>
#include <type_traits>

#include <measurement_kit/common/error.hpp>
#include <measurement_kit/common/logger.hpp>
#include <measurement_kit/common/nlohmann/json.hpp>
#include <measurement_kit/common/shared_ptr.hpp>

#include "src/libmeasurement_kit/common/reactor.hpp"
#include "src/libmeasurement_kit/nettests/runnable.hpp"

namespace mk {
namespace engine {

// # Multi-thread stuff
//
// Comes first because it needs more careful handling.

class TaskImpl {
  public:
    std::condition_variable cond;
    std::deque<nlohmann::json> deque;
    std::atomic_bool interrupted{false};
    std::mutex mutex;
    SharedPtr<Reactor> reactor = Reactor::make();
    std::atomic_bool running{false};
    std::thread thread;
};

static void task_run(TaskImpl *pimpl, nlohmann::json &settings);
static nlohmann::json possibly_validate_event(nlohmann::json &&);

static void emit(TaskImpl *pimpl, nlohmann::json &&event) {
    // Perform validation of the event (debug mode only)
    event = possibly_validate_event(std::move(event));
    // Actually emit the event.
    {
        std::unique_lock<std::mutex> _{pimpl->mutex};
        pimpl->deque.push_back(std::move(event));
    }
    pimpl->cond.notify_all(); // more efficient if unlocked
}

Task::Task(nlohmann::json &&settings) {
    pimpl_ = std::make_unique<TaskImpl>();
    // The purpose of `barrier` is to wait in the constructor until the
    // thread for running the test is up and running.
    std::promise<void> barrier;
    std::future<void> started = barrier.get_future();
    pimpl_->thread = std::thread([this, &barrier, settings = std::move(settings)]() mutable {
        pimpl_->running = true;
        barrier.set_value();
        {
            nlohmann::json event;
            event["key"] = "status.queued";
            event["value"] = nlohmann::json::object();
            emit(pimpl_.get(), std::move(event));
        }
        static std::mutex semaphore;
        std::unique_lock<std::mutex> _{semaphore};  // prevent concurrent tasks
        task_run(pimpl_.get(), settings);
        pimpl_->running = false;
        pimpl_->cond.notify_all(); // tell the readers we're done
    });
    started.wait(); // guarantee the thread is running when Task() returns
}

bool Task::is_done() const {
    std::unique_lock<std::mutex> lock{pimpl_->mutex};
    // Rationale: when the task thread terminates, there may be some
    // unread events in queue. We do not consider the task as done until
    // such events have been read and processed by our controller.
    return pimpl_->running == false && pimpl_->deque.empty();
}

void Task::interrupt() {
    // both variables are safe to use in a MT context
    pimpl_->reactor->stop();
    pimpl_->interrupted = true;
}

nlohmann::json Task::wait_for_next_event() {
    std::unique_lock<std::mutex> lock{pimpl_->mutex};
    // purpose: block here until we stop running or we have events to read
    pimpl_->cond.wait(lock, [this]() { //
        return !pimpl_->running || !pimpl_->deque.empty();
    });
    // must be first so we drain the queue before emitting the final
    // "task_terminated" event.
    if (!pimpl_->deque.empty()) {
        auto rv = std::move(pimpl_->deque.front());
        pimpl_->deque.pop_front();
        return rv;
    }
    assert(!pimpl_->running);
    // Rationale: we used to return `null` when done. But then I figured that
    // this could break people code, because they need to write conditional
    // coding for handling both an ordinary event and `null`. So, to ease the
    // integrator's life, we now return a dummy, well formed event.
    return possibly_validate_event(nlohmann::json{
        {"key", "task_terminated"},
        {"value", nlohmann::json::object()},
    });
}

Task::~Task() {
    if (pimpl_->thread.joinable()) {
        pimpl_->thread.join();
    }
}

// # Helpers

static std::tuple<int, bool> log_level_atoi(const std::string &str) {
    if (str == "ERR") {
        return std::make_tuple(MK_LOG_ERR, true);
    }
    if (str == "WARNING") {
        return std::make_tuple(MK_LOG_WARNING, true);
    }
    if (str == "INFO") {
        return std::make_tuple(MK_LOG_INFO, true);
    }
    if (str == "DEBUG") {
        return std::make_tuple(MK_LOG_DEBUG, true);
    }
    if (str == "DEBUG2") {
        return std::make_tuple(MK_LOG_DEBUG2, true);
    }
    return std::make_tuple(0, false);
}

static std::tuple<std::string, bool> log_level_itoa(int n) {
    if (n == MK_LOG_ERR) {
        return std::make_tuple(std::string{"ERR"}, true);
    }
    if (n == MK_LOG_WARNING) {
        return std::make_tuple(std::string{"WARNING"}, true);
    }
    if (n == MK_LOG_INFO) {
        return std::make_tuple(std::string{"INFO"}, true);
    }
    if (n == MK_LOG_DEBUG) {
        return std::make_tuple(std::string{"DEBUG"}, true);
    }
    if (n == MK_LOG_DEBUG2) {
        return std::make_tuple(std::string{"DEBUG2"}, true);
    }
    return std::make_tuple(std::string{}, false);
}

static nlohmann::json make_log_event(uint32_t log_level, const char *message) {
    auto log_level_tuple = log_level_itoa(log_level);
    assert(std::get<1>(log_level_tuple));
    const std::string &vs = std::get<0>(log_level_tuple);
    nlohmann::json object;
    object["key"] = "log";
    object["value"]["log_level"] = vs;
    object["value"]["message"] = message;
    return object;
}

static nlohmann::json make_failure_event(const Error &error) {
    nlohmann::json object;
    object["key"] = "failure.startup";
    object["value"]["failure"] = error.reason;
    return object;
}

static bool is_event_key_valid(const std::string &str) {
    return (str == "bug.json_dump") ||
        (str == "failure.asn_lookup") ||
        (str == "failure.cc_lookup") ||
        (str == "failure.ip_lookup") ||
        (str == "failure.measurement") ||
        (str == "failure.measurement_submission") ||
        (str == "failure.network_name_lookup") ||
        (str == "failure.report_create") ||
        (str == "failure.report_close") ||
        (str == "failure.resolver_lookup") ||
        (str == "failure.startup") ||
        (str == "log") ||
        (str == "measurement") ||
        (str == "status.end") ||
        (str == "status.geoip_lookup") ||
        (str == "status.progress") ||
        (str == "status.queued") ||
        (str == "status.measurement_start") ||
        (str == "status.measurement_submission") ||
        (str == "status.measurement_done") ||
        (str == "status.report_close") ||
        (str == "status.report_create") ||
        (str == "status.resolver_lookup") ||
        (str == "status.started") ||
        (str == "status.update.performance") ||
        (str == "status.update.websites") ||
        (str == "task_terminated");
}

static nlohmann::json possibly_validate_event(nlohmann::json &&event) {
    // In debug mode, make sure that we're emitting an event that we know
    assert(event.is_object());
    assert(event.count("key") != 0);
    assert(event.at("key").is_string());
    assert(is_event_key_valid(event.at("key").get<std::string>()));
    assert(event.count("value") != 0);
    assert(event.at("value").is_object());
    do {
        // Note: in the following we check the fields of events. As such, all
        // the events with no fields of course do not appear in here.
        if (event.at("key") == "bug.json_dump") {
            assert(event.at("value").count("failure") == 1);
            assert(event.at("value").at("failure").is_string());
            assert(event.at("value").count("orig_key") == 1);
            assert(event.at("value").at("orig_key").is_string());
            break;
        }
        if (event.at("key") == "failure.asn_lookup") {
            assert(event.at("value").count("failure") == 1);
            assert(event.at("value").at("failure").is_string());
            break;
        }
        if (event.at("key") == "failure.cc_lookup") {
            assert(event.at("value").count("failure") == 1);
            assert(event.at("value").at("failure").is_string());
            break;
        }
        if (event.at("key") == "failure.ip_lookup") {
            assert(event.at("value").count("failure") == 1);
            assert(event.at("value").at("failure").is_string());
            break;
        }
        if (event.at("key") == "failure.measurement") {
            assert(event.at("value").count("failure") == 1);
            assert(event.at("value").at("failure").is_string());
            break;
        }
        if (event.at("key") == "failure.measurement_submission") {
            assert(event.at("value").count("failure") == 1);
            assert(event.at("value").at("failure").is_string());
            assert(event.at("value").count("idx") == 1);
            assert(event.at("value").at("idx").is_number_integer());
            assert(event.at("value").count("json_str") == 1);
            assert(event.at("value").at("json_str").is_string());
            break;
        }
        if (event.at("key") == "failure.network_name_lookup") {
            assert(event.at("value").count("failure") == 1);
            assert(event.at("value").at("failure").is_string());
            break;
        }
        if (event.at("key") == "failure.report_create") {
            assert(event.at("value").count("failure") == 1);
            assert(event.at("value").at("failure").is_string());
            break;
        }
        if (event.at("key") == "failure.report_close") {
            assert(event.at("value").count("failure") == 1);
            assert(event.at("value").at("failure").is_string());
            break;
        }
        if (event.at("key") == "failure.resolver_lookup") {
            assert(event.at("value").count("failure") == 1);
            assert(event.at("value").at("failure").is_string());
            break;
        }
        if (event.at("key") == "failure.startup") {
            assert(event.at("value").count("failure") == 1);
            assert(event.at("value").at("failure").is_string());
            break;
        }
        if (event.at("key") == "log") {
            assert(event.at("value").count("log_level") == 1);
            assert(event.at("value").at("log_level").is_string());
            assert(event.at("value").count("message") == 1);
            assert(event.at("value").at("message").is_string());
            break;
        }
        if (event.at("key") == "measurement") {
            assert(event.at("value").count("idx") == 1);
            assert(event.at("value").at("idx").is_number_integer());
            assert(event.at("value").count("json_str") == 1);
            assert(event.at("value").at("json_str").is_string());
            break;
        }
        if (event.at("key") == "status.end") {
            assert(event.at("value").count("downloaded_kb") == 1);
            assert(event.at("value").at("downloaded_kb").is_number_float());
            assert(event.at("value").count("uploaded_kb") == 1);
            assert(event.at("value").at("uploaded_kb").is_number_float());
            assert(event.at("value").count("failure") == 1);
            assert(event.at("value").at("failure").is_string());
            break;
        }
        if (event.at("key") == "status.geoip_lookup") {
            assert(event.at("value").count("probe_ip") == 1);
            assert(event.at("value").at("probe_ip").is_string());
            assert(event.at("value").count("probe_asn") == 1);
            assert(event.at("value").at("probe_asn").is_string());
            assert(event.at("value").count("probe_cc") == 1);
            assert(event.at("value").at("probe_cc").is_string());
            assert(event.at("value").count("probe_network_name") == 1);
            assert(event.at("value").at("probe_network_name").is_string());
            break;
        }
        if (event.at("key") == "status.progress") {
            assert(event.at("value").count("percentage") == 1);
            assert(event.at("value").at("percentage").is_number_float());
            assert(event.at("value").count("message") == 1);
            assert(event.at("value").at("message").is_string());
            break;
        }
        if (event.at("key") == "status.measurement_start") {
            assert(event.at("value").count("idx") == 1);
            assert(event.at("value").at("idx").is_number_integer());
            assert(event.at("value").count("input") == 1);
            assert(event.at("value").at("input").is_string());
            break;
        }
        if (event.at("key") == "status.measurement_submission") {
            assert(event.at("value").count("idx") == 1);
            assert(event.at("value").at("idx").is_number_integer());
            break;
        }
        if (event.at("key") == "status.measurement_done") {
            assert(event.at("value").count("idx") == 1);
            assert(event.at("value").at("idx").is_number_integer());
            break;
        }
        if (event.at("key") == "status.report_close") {
            assert(event.at("value").count("report_id") == 1);
            assert(event.at("value").at("report_id").is_string());
            break;
        }
        if (event.at("key") == "status.report_create") {
            assert(event.at("value").count("report_id") == 1);
            assert(event.at("value").at("report_id").is_string());
            break;
        }
        if (event.at("key") == "status.resolver_lookup") {
            assert(event.at("value").count("ip_address") == 1);
            assert(event.at("value").at("ip_address").is_string());
            break;
        }
        if (event.at("key") == "status.update.performance") {
            assert(event.at("value").count("direction") == 1);
            assert(event.at("value").at("direction").is_string());
            assert(event.at("value").count("elapsed") == 1);
            assert(event.at("value").at("elapsed").is_number_float());
            assert(event.at("value").count("num_streams") == 1);
            assert(event.at("value").at("num_streams").is_number_integer());
            assert(event.at("value").count("speed_kbps") == 1);
            assert(event.at("value").at("speed_kbps").is_number_float());
            break;
        }
        if (event.at("key") == "status.update.websites") {
            assert(event.at("value").count("url") == 1);
            assert(event.at("value").at("url").is_string());
            assert(event.at("value").count("status") == 1);
            assert(event.at("value").at("status").is_string());
            break;
        }
    } while (0);
    return event;
}

static nlohmann::json known_events() {
    nlohmann::json json;
    json.push_back("bug.json_dump");
    json.push_back("failure.asn_lookup");
    json.push_back("failure.cc_lookup");
    json.push_back("failure.ip_lookup");
    json.push_back("failure.measurement");
    json.push_back("failure.measurement_submission");
    json.push_back("failure.network_name_lookup");
    json.push_back("failure.report_create");
    json.push_back("failure.report_close");
    json.push_back("failure.resolver_lookup");
    json.push_back("failure.startup");
    json.push_back("log");
    json.push_back("measurement");
    json.push_back("status.end");
    json.push_back("status.geoip_lookup");
    json.push_back("status.progress");
    json.push_back("status.queued");
    json.push_back("status.measurement_start");
    json.push_back("status.measurement_submission");
    json.push_back("status.measurement_done");
    json.push_back("status.report_close");
    json.push_back("status.report_create");
    json.push_back("status.resolver_lookup");
    json.push_back("status.started");
    json.push_back("status.update.performance");
    json.push_back("status.update.websites");
    json.push_back("task_terminated");
    return json;
}

static std::string known_tasks() {
    nlohmann::json json;
    json.push_back("CaptivePortal");
    json.push_back("Dash");
    json.push_back("DnsInjection");
    json.push_back("FacebookMessenger");
    json.push_back("HttpHeaderFieldManipulation");
    json.push_back("HttpInvalidRequestLine");
    json.push_back("MeekFrontedRequests");
    json.push_back("MultiNdt");
    json.push_back("Ndt");
    json.push_back("TcpConnect");
    json.push_back("Telegram");
    json.push_back("WebConnectivity");
    json.push_back("Whatsapp");
    return json.dump();
}

static std::string known_log_level_levels() {
    nlohmann::json json;
    json.push_back("err");
    json.push_back("warning");
    json.push_back("info");
    json.push_back("debug");
    json.push_back("debug2");
    return json.dump();
}

static std::unique_ptr<nettests::Runnable> make_runnable(const std::string &s) {
    std::unique_ptr<nettests::Runnable> runnable;
    if (s == "CaptivePortal") {
        runnable.reset(new nettests::CaptivePortalRunnable);
        return runnable;
    }
    if (s == "Dash") {
        runnable.reset(new nettests::DashRunnable);
        return runnable;
    }
    if (s == "DnsInjection") {
        runnable.reset(new nettests::DnsInjectionRunnable);
        return runnable;
    }
    if (s == "FacebookMessenger") {
        runnable.reset(new nettests::FacebookMessengerRunnable);
        return runnable;
    }
    if (s == "HttpHeaderFieldManipulation") {
        runnable.reset(new nettests::HttpHeaderFieldManipulationRunnable);
        return runnable;
    }
    if (s == "HttpInvalidRequestLine") {
        runnable.reset(new nettests::HttpInvalidRequestLineRunnable);
        return runnable;
    }
    if (s == "MeekFrontedRequests") {
        runnable.reset(new nettests::MeekFrontedRequestsRunnable);
        return runnable;
    }
    if (s == "MultiNdt") {
        runnable.reset(new nettests::MultiNdtRunnable);
        return runnable;
    }
    if (s == "Ndt") {
        runnable.reset(new nettests::NdtRunnable);
        return runnable;
    }
    if (s == "TcpConnect") {
        runnable.reset(new nettests::TcpConnectRunnable);
        return runnable;
    }
    if (s == "Telegram") {
        runnable.reset(new nettests::TelegramRunnable);
        return runnable;
    }
    if (s == "WebConnectivity") {
        runnable.reset(new nettests::WebConnectivityRunnable);
        return runnable;
    }
    if (s == "Whatsapp") {
        runnable.reset(new nettests::WhatsappRunnable);
        return runnable;
    }
    // Note: it is okay for this function to return an empty unique_ptr.
    return runnable;
}

static void emit_settings_failure(TaskImpl *pimpl, const char *reason) {
    emit(pimpl, make_log_event(MK_LOG_ERR, reason));
    emit(pimpl, make_failure_event(ValueError()));
}

static void emit_settings_warning(TaskImpl *pimpl, const char *reason) {
    emit(pimpl, make_log_event(MK_LOG_WARNING, reason));
}

static bool validate_known_settings_shallow(
        TaskImpl *pimpl, const nlohmann::json &settings) {
    auto rv = true;

    // This function does not short circuit failure so that we warn the user
    // about all the issues with the JSON that was provided to us.

    // Ensure that name is present
    if (settings.count("name") <= 0) {
        std::stringstream ss;
        ss << "missing required setting 'name' (fyi: "
           << "name should be a string)";
        emit_settings_warning(pimpl, ss.str().data());
        rv = false;
    }

    // Make sure that annotations has the correct type
    if (settings.count("annotations") > 0 && !settings.at("annotations").is_object()) {
        std::stringstream ss;
        ss << "found setting 'annotations' with invalid type (fyi: "
           << "annotations should be a object)";
        emit_settings_warning(pimpl, ss.str().data());
        rv = false;
    }
    // Make sure that disabled_events has the correct type
    if (settings.count("disabled_events") > 0 && !settings.at("disabled_events").is_array()) {
        std::stringstream ss;
        ss << "found setting 'disabled_events' with invalid type (fyi: "
           << "disabled_events should be a array)";
        emit_settings_warning(pimpl, ss.str().data());
        rv = false;
    }
    // Make sure that inputs has the correct type
    if (settings.count("inputs") > 0 && !settings.at("inputs").is_array()) {
        std::stringstream ss;
        ss << "found setting 'inputs' with invalid type (fyi: "
           << "inputs should be a array)";
        emit_settings_warning(pimpl, ss.str().data());
        rv = false;
    }
    // Make sure that input_filepaths has the correct type
    if (settings.count("input_filepaths") > 0 && !settings.at("input_filepaths").is_array()) {
        std::stringstream ss;
        ss << "found setting 'input_filepaths' with invalid type (fyi: "
           << "input_filepaths should be a array)";
        emit_settings_warning(pimpl, ss.str().data());
        rv = false;
    }
    // Make sure that log_filepath has the correct type
    if (settings.count("log_filepath") > 0 && !settings.at("log_filepath").is_string()) {
        std::stringstream ss;
        ss << "found setting 'log_filepath' with invalid type (fyi: "
           << "log_filepath should be a string)";
        emit_settings_warning(pimpl, ss.str().data());
        rv = false;
    }
    // Make sure that log_level has the correct type
    if (settings.count("log_level") > 0 && !settings.at("log_level").is_string()) {
        std::stringstream ss;
        ss << "found setting 'log_level' with invalid type (fyi: "
           << "log_level should be a string)";
        emit_settings_warning(pimpl, ss.str().data());
        rv = false;
    }
    // Make sure that name has the correct type
    if (settings.count("name") > 0 && !settings.at("name").is_string()) {
        std::stringstream ss;
        ss << "found setting 'name' with invalid type (fyi: "
           << "name should be a string)";
        emit_settings_warning(pimpl, ss.str().data());
        rv = false;
    }
    // Make sure that options has the correct type
    if (settings.count("options") > 0 && !settings.at("options").is_object()) {
        std::stringstream ss;
        ss << "found setting 'options' with invalid type (fyi: "
           << "options should be a object)";
        emit_settings_warning(pimpl, ss.str().data());
        rv = false;
    }
    // Make sure that output_filepath has the correct type
    if (settings.count("output_filepath") > 0 && !settings.at("output_filepath").is_string()) {
        std::stringstream ss;
        ss << "found setting 'output_filepath' with invalid type (fyi: "
           << "output_filepath should be a string)";
        emit_settings_warning(pimpl, ss.str().data());
        rv = false;
    }

    return rv;
}

// TODO(bassosimone): decide whether this should instead stop processing.
static void remove_unknown_settings_and_warn(
        TaskImpl *pimpl, nlohmann::json &settings) {
    std::set<std::string> expected;
    std::set<std::string> unexpected;
    expected.insert("annotations");
    expected.insert("disabled_events");
    expected.insert("inputs");
    expected.insert("input_filepaths");
    expected.insert("log_filepath");
    expected.insert("log_level");
    expected.insert("name");
    expected.insert("options");
    expected.insert("output_filepath");
    for (auto it : settings.items()) {
        const auto &key = it.key();
        if (expected.count(key) <= 0) {
            std::stringstream ss;
            ss << "found unknown setting key " << key << " which will be "
               << "removed from the settings JSON.";
            unexpected.insert(key);
            emit_settings_warning(pimpl, ss.str().data());
        }
    }
    for (auto &s : unexpected) {
        settings.erase(s);
    }
}

// # Run task

static void task_run(TaskImpl *pimpl, nlohmann::json &settings) {

    // make sure that `settings` is an object
    if (!settings.is_object()) {
        std::stringstream ss;
        ss << "invalid `settings` type: the `settings` JSON that you pass me "
            << "should be a JSON object (i.e. '{\"type\": \"Ndt\"}') but "
            << "instead you passed me this: '" << settings.dump() << "'";
        emit_settings_failure(pimpl, ss.str().data());
        return;
    }

    // Make sure that the toplevel settings are okay, remove unknown ones, so
    // there cannot be code below attempting to access settings that are not
    // specified also inside of the <engine.h> header file.
    if (!validate_known_settings_shallow(pimpl, settings)) {
        emit_settings_failure(pimpl, "failed to validate settings");
        return;
    }
    remove_unknown_settings_and_warn(pimpl, settings);

    // extract and process `name`
    auto runnable = make_runnable(settings.at("name").get<std::string>());
    if (!runnable) {
        std::stringstream ss;
        ss << "unknown task name '" << settings.at("name").get<std::string>()
            << "' (fyi: known tasks are: " << known_tasks() << ")";
        emit_settings_failure(pimpl, ss.str().data());
        return;
    }
    runnable->reactor = pimpl->reactor; // default is nullptr, we must set it

    // extract and process `options`
    if (settings.count("options") != 0) {
        auto &options = settings.at("options");
        for (auto it : options.items()) {
            const auto &key = it.key();
            auto &value = it.value();
            // TODO(bassosimone): currently we do not perform strict validation
            // of options, rather we only check the type of the options that
            // have been mapped. Even in such case, we cannot for now bail as
            // the legacy API allows all options to be defined as string. We
            // also warn when we see an unknown option, so that we will see if
            // we have not mapped a specific option.
            {
                bool found = false;
                do {
                    if (key == "all_endpoints") {
                        found = true;
                        if (!value.is_boolean()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "boolean)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "bouncer_base_url") {
                        found = true;
                        if (!value.is_string()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "string)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "collector_base_url") {
                        found = true;
                        if (!value.is_string()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "string)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "dns/nameserver") {
                        found = true;
                        if (!value.is_string()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "string)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "dns/engine") {
                        found = true;
                        if (!value.is_string()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "string)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "geoip_asn_path") {
                        found = true;
                        if (!value.is_string()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "string)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "geoip_country_path") {
                        found = true;
                        if (!value.is_string()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "string)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "ignore_bouncer_error") {
                        found = true;
                        if (!value.is_boolean()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "boolean)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "ignore_open_report_error") {
                        found = true;
                        if (!value.is_boolean()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "boolean)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "max_runtime") {
                        found = true;
                        if (!value.is_number_integer()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "number_integer)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "mlabns/address_family") {
                        found = true;
                        if (!value.is_string()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "string)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "mlabns/base_url") {
                        found = true;
                        if (!value.is_string()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "string)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "mlabns/country") {
                        found = true;
                        if (!value.is_string()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "string)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "mlabns/metro") {
                        found = true;
                        if (!value.is_string()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "string)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "mlabns/policy") {
                        found = true;
                        if (!value.is_string()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "string)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "net/ca_bundle_path") {
                        found = true;
                        if (!value.is_string()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "string)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "net/timeout") {
                        found = true;
                        if (!value.is_number_float()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "number_float)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "no_bouncer") {
                        found = true;
                        if (!value.is_boolean()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "boolean)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "no_collector") {
                        found = true;
                        if (!value.is_boolean()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "boolean)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "no_file_report") {
                        found = true;
                        if (!value.is_boolean()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "boolean)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "port") {
                        found = true;
                        if (!value.is_number_integer()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "number_integer)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "probe_ip") {
                        found = true;
                        if (!value.is_string()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "string)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "probe_asn") {
                        found = true;
                        if (!value.is_string()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "string)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "probe_cc") {
                        found = true;
                        if (!value.is_string()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "string)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "probe_network_name") {
                        found = true;
                        if (!value.is_string()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "string)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "randomize_input") {
                        found = true;
                        if (!value.is_boolean()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "boolean)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "save_real_probe_asn") {
                        found = true;
                        if (!value.is_boolean()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "boolean)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "save_real_probe_cc") {
                        found = true;
                        if (!value.is_boolean()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "boolean)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "save_real_probe_ip") {
                        found = true;
                        if (!value.is_boolean()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "boolean)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "save_real_probe_network_name") {
                        found = true;
                        if (!value.is_boolean()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "boolean)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "save_real_resolver_ip") {
                        found = true;
                        if (!value.is_boolean()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "boolean)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "server") {
                        found = true;
                        if (!value.is_string()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "string)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "software_name") {
                        found = true;
                        if (!value.is_string()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "string)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                    if (key == "software_version") {
                        found = true;
                        if (!value.is_string()) {
                            std::stringstream ss;
                            ss << "Found " << key << " option which has the "
                               << "wrong type (fyi: it should be a "
                               << "string)";
                            emit_settings_warning(pimpl, ss.str().data());
                            // FALLTHROUGH
                        }
                        break;
                    }
                } while (0);
                if (!found) {
                    std::stringstream ss;
                    ss << "Found " << key << " option which is not mapped "
                       << "as a valid option. We will continue processing";
                    emit_settings_warning(pimpl, ss.str().data());
                }
            }
            // The following block of code is the old code used for options
            // processing which generically makes sure that the type is a
            // supported type and performs fixes required to make string options
            // work correctly because of bugs inside of MK.
            if (value.is_string()) {
                const auto &v = value.get<std::string>();
                if (v == "") {
                    // TODO(bassosimone): modify the Scalar class so that it
                    // does not break if we set the value as an empty string and
                    // we then attempt to extract a string. This is currently a
                    // nasty bug that, without this workaround, makes the life
                    // of people integrating MK quite annoying.
                    continue;
                }
                // Using emplace() as a workaround for bug #1550.
                runnable->options.emplace(key, v);
            } else if (value.is_number_integer()) {
                auto v = value.get<int64_t>();
                runnable->options[key] = v;
            } else if (value.is_number_float()) {
                auto v = value.get<double>();
                runnable->options[key] = v;
            } else if (value.is_boolean()) {
                auto v = value.get<bool>();
                runnable->options[key] = (v) ? 1 : 0;
            } else {
                std::stringstream ss;
                ss << "Found option '" << key << "' to have an invalid type"
                    << " (fyi: valid types are: int, double, string)";
                emit_settings_failure(pimpl, ss.str().data());
                return;
            }
        }
    }

    // extract and process `annotations`
    if (settings.count("annotations") != 0) {
        auto &annotations = settings.at("annotations");
        for (auto it : annotations.items()) {
            const auto &key = it.key();
            auto &value = it.value();
            // TODO(bassosimone): make sure that we preserve the _type_ of
            // the annotation in the final report rather than converting such
            // type into a string, which is currently what we do.
            //
            // Actually, I am wondering whether we need to have annotations
            // of different types or we can just always use strings.
            if (value.is_string()) {
                runnable->annotations[key] = value.get<std::string>();
            } else if (value.is_number_integer()) {
                int64_t intvalue = value.get<int64_t>();
                runnable->annotations[key] = std::to_string(intvalue);
            } else if (value.is_number_float()) {
                double doublevalue = value.get<double>();
                runnable->annotations[key] = std::to_string(doublevalue);
            } else {
                std::stringstream ss;
                ss << "Found annotation '" << key << "' to have an invalid type"
                    << " (fyi: valid types are: int, double, string)";
                emit_settings_failure(pimpl, ss.str().data());
                return;
            }
        }
    }

    // extract and process `inputs`
    if (settings.count("inputs") != 0) {
        for (auto &value : settings.at("inputs")) {
            if (value.is_string()) {
                runnable->inputs.push_back(value.get<std::string>());
            } else {
                std::stringstream ss;
                ss << "Found input '" << value << "' to have an invalid type"
                    << " (fyi: values inside 'inputs' must be strings)";
                emit_settings_failure(pimpl, ss.str().data());
                return;
            }
        }
    }

    // extract and process `input_filepaths`
    if (settings.count("input_filepaths") != 0) {
        for (auto &value : settings.at("input_filepaths")) {
            if (value.is_string()) {
                runnable->input_filepaths.push_back(value.get<std::string>());
            } else {
                std::stringstream ss;
                ss << "Found input_filepath '" << value << "' to have an "
                   << "invalid type (fyi: values inside 'input_filepaths' "
                   << "must be strings)";
                emit_settings_failure(pimpl, ss.str().data());
                return;
            }
        }
    }

    // extract and process `log_filepath`
    if (settings.count("log_filepath") != 0) {
        // Remark: here we're using .at() and .get(), which MAY both throw,
        // since we have already validated the settings type above.
        auto &value = settings.at("log_filepath");
        runnable->logger->set_logfile(value.get<std::string>());
    }

    // extract and process `output_filepath`
    if (settings.count("output_filepath") != 0) {
        auto &value = settings.at("output_filepath");
        runnable->output_filepath = value.get<std::string>();
    }

    // extract and process `log_level`
    {
        uint32_t log_level = MK_LOG_WARNING;
        if (settings.count("log_level") != 0) {
            auto log_level_string = settings.at("log_level").get<std::string>();
            auto log_level_tuple = log_level_atoi(log_level_string);
            bool okay = std::get<1>(log_level_tuple);
            if (!okay) {
                std::stringstream ss;
                ss << "Unknown log_level level '" << log_level_string << "' "
                    << "(fyi: known log_level levels are: " <<
                    known_log_level_levels() << ")";
                emit_settings_failure(pimpl, ss.str().data());
                return;
            }
            log_level = std::get<0>(log_level_tuple);
        }
        runnable->logger->set_verbosity(log_level);
    }

    // Mask out events that are user-disabled.
    std::set<std::string> enabled_events = known_events();
    if (settings.count("disabled_events") != 0) {
        for (auto &entry : settings.at("disabled_events")) {
            if (!entry.is_string()) {
                std::stringstream ss;
                ss << "Found invalid entry inside of disabled_events that "
                  << "has value equal to <" << entry.dump() << "> (fyi: all "
                  << "the entries in disabled_events must be strings)";
                emit_settings_failure(pimpl, ss.str().data());
                return;
            }
            std::string s = entry.get<std::string>();
            if (!is_event_key_valid(s)) {
                std::stringstream ss;
                ss << "Found unknown event inside of disabled_events with "
                   << "name '" << s << "' (fyi: all valid events are: "
                   << known_events().dump() << "). Measurement Kit is going "
                   << "to ignore this invalid event and continue";
                emit_settings_warning(pimpl, ss.str().data());
                continue;
            }
            enabled_events.erase(s);
        }
    }

    // see whether 'log' is enabled
    if (enabled_events.count("log") != 0) {
        runnable->logger->on_log([pimpl](uint32_t log_level, const char *line) {
            if ((log_level & ~MK_LOG_VERBOSITY_MASK) != 0) {
                return; // mask out non-logging events
            }
            emit(pimpl, make_log_event(log_level, line));
        });
        enabled_events.erase("log"); // we have consumed this event key
    } else {
        runnable->logger->on_log(nullptr);
    }

    // intercept and route all the other (i.e. non "log") events
    for (auto &event : enabled_events) {
        runnable->logger->on_event_ex(event, [pimpl](nlohmann::json &&event) {
            emit(pimpl, std::move(event));
        });
    }
    // route also disabled events so that we get to validate them when we are
    // running in debug mode (i.e. NDEBUG is not defined).
    runnable->logger->on_event_ex("__disabled", [](nlohmann::json &&event) {
        (void)possibly_validate_event(std::move(event));
    });

    runnable->logger->emit_event_ex("status.started", nlohmann::json::object());

    // start the task (reactor and interrupted are MT safe)
    Error error = GenericError();
    pimpl->reactor->run_with_initial_event([&]() {
        if (pimpl->interrupted) {
            return; // allow for early interruption
        }
        runnable->begin([&](Error err) {
            error = err;
            runnable->end([&](Error err) {
                if (error != NoError()) {
                    error = err;
                }
            });
        });
    });

    DataUsage du;
    runnable->reactor->with_current_data_usage([&](DataUsage &x) {
        du = x;
    });
    runnable->logger->emit_event_ex("status.end", {
        {"downloaded_kb", du.down / 1024.0},
        {"failure", error.reason},
        {"uploaded_kb", du.up / 1024.0},
    });
}

} // namespace engine
} // namespace mk
