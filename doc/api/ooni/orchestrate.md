# NAME
orchestrate -- code to talk to OONI's orchestrator

# LIBRARY
MeasurementKit (`libmeasurement_kit`, `-lmeasurement_kit`).

# SYNOPSIS
```C++
#include <measurement_kit/ooni.hpp>

namespace mk {
namespace ooni {
namespace orchestrate {

std::string production_registry_url();
std::string testing_registry_url();

std::string production_events_url();
std::string testing_events_url();

class Client {
  public:
    Var<Logger> logger = Logger::global();
    Settings settings = {};
    std::string available_bandwidth;
    std::string device_token;
    std::string events_url = production_events_url();
    std::string language;
    std::string network_type;
    std::string geoip_country_path;
    std::string geoip_asn_path;
    std::string platform;
    std::string probe_asn;
    std::string probe_cc;
    std::string probe_family;
    std::string registry_url = production_registry_url();
    std::string secrets_path = "orchestrator_secrets.json";
    std::string software_name = "measurement_kit";
    std::string software_version = MK_VERSION;
    std::vector<std::string> supported_tests;

    void register_probe(Callback<Error &&> &&callback) const;
    void update(Callback<Error &&> &&callback) const;
    void list_tasks(Callback<Error &&, std::vector<Task> &&> &&callback) const;
};

class Task {
  public:
    std::string events_url = production_events_url();
    std::string task_id;

    void get(Callback<Error &&, std::string &&> &&callback) const;
    void accept(Callback<Error &&> &&callback) const;
    void reject(Callback<Error &&> &&callback) const;
    void done(Callback<Error &&> &&callback) const;
};

} // namespace orchestrate
} // namespace ooni
} // namespace mk
```

# STABILITY

1 - Experimental

# DESCRIPTION

The orchestrator client communicates with OONI's orchestrator. That is a set
of services telling clients which tests it is most optimal to run, and with
what inputs. This allows OONI to maximize censorship coverage given the probe's
current geographic location and internet service provider.

The `production_registry_url`, `testing_registry_url`, `production_events_url`,
and `testing_events_url` return, respectively, the production and testing URLs
of the orchestrator's registry and events web services used by OONI.

Once you have constructed an orchestration client, you can configure it by
setting the proper configuration attributes, described below:

The `logger` attribute can be override to use a custom logger. By default, the
global MeasurementKit logger is used.

The `settings` attribute allows to specify optional settings. By default, an
empty settings object is used, meaning that defaults will always be used.

The `available_bandwidth` attribute indicates how much bandwidth you would
like to use for automatic tests run through orchestration. By default, this
attribute is empty, meaning that no bandwidth quota will be enforced.

The `device_token` attribute uniquely identifies the app inside a device, and
is only meaningful in the mobile context. This token is generated by the mobile
OS for the current application and is used to identify it.

The `events_url` attribute contains the URL used to query the `events` web
service of the orchestrator. By default, this attribute is set to the production
events service URL used by OONI.

The `language` attribute tells the orchestrator the language used by
this probe. By default this attribute is unspecified.

The `network_type` attribute tells the orchestrator the type of the network
the probe is connected to (i.e. Wi-Fi or mobile). By default this attribute is
unspecified.

The `geoip_country_path` and `geoip_asn_path` are used by the orchestrator
client to guess the country and autonomous system number, if they are not
provided by the API user (see below). By default these attributes are empty,
meaning that MK will not attempt to geolocate the user.

The `platform` attribute tells the orchestrator the platform in
which the probe runs (e.g., `android`, `ios`). If not set, this
attribute will be filled automatically by MeasurementKit when the
actual request for the orchestrator is prepared.

The `probe_asn` attribute tells the orchestrator the autonomous
system number (ASN) of the ISP that the probe is connected to. If
not set, this attribute will be filled automatically by MeasurementKit
when the actual request for the orchestrator is prepared.

The `probe_cc` attribute tells the orchestrator the country code
of the country in which the probe currently is. If not set, this
attribute will be filled automatically by MeasurementKit when the
actual request for the orchestrator is prepared.

The `probe_family` attribute allows to bind a set of different
probes to a common family of probes. This attribute is currently
reserved for future use.

The `registry_url` attribute contains the URL used to query the
`registry` web service of the orchestrator. By default, this attribute
is set to the production registry service URL used by OONI.

The `secrets_path` attribute is the path of the file where to save
orchestrator secrets. The default is `"orchestrator_secrets.json"` in
the current working directory. You certainly want to change this on
mobile device, to use a directory where the app can write.

The `software_name` attribute is the name of the application using
MeasurementKit OONI's orchestrator. By default is `measurement_kit`
and you most certainly want to change it to the name of your
application.

The `software_version` attribute is the version of the application
using MeasurementKit OONI's orchestrator. By default is the current
version of MeasurementKit and you most certainly want to change it
to the version of your application.

The `supported_tests` attribute is the vector of test names supported
by OONI that the application would like to support. If not set,
this field is filled by MeasurementKit with the list of implemented
tests when preparing the request for the orchestrator.

Once the orchestrator client is configured, you can use its methods to send
requests to the orchestrator server. The following methods are available:

The `register_probe` method registers the current probe with the
orchestrator system. If the probe is already registered, this
operation is a no-op. Otherwise, it will register the probe with
the orchestrator system. The parameter passed to the callback
indicates whether there was an error.

The `update` method assumes that a probe is already registered and
updates the orchestrator system's knowledge of the state of a probe
(e.g. network type, location). The parameter passed to callback
indicates whether there was an error.

The `list_tasks` method assumes that a probe is already registered
and gets the list of tasks to run. The callback receives two parameters:
whether there was an error and the list of tasks.

Each task is an instance of the `Task` class.

The `list_tasks` callback receives as argument already configured `Task`
instances. In particular, this means that the following attributes are set:

The `events_url` attribute should point to the URL to be used to contact the
`events` web service of the orchestrator. By default this is initialized by
the orchestrator code to point to the production events URL.

The `task_id` attribute should contain the ID of the task. By default this is
initialized by the orchestrator code to be the ID of the task as returned by
the orchestrator services.

The `Task` instance could then be used to perform the following operations:

The `get` method retrieves from the `events` web service the JSON data
associated to the task. The semantic of this data depends on the type of
task. The `Error` parameter indicates whether there was an error and
the `string` parameter is a serialized JSON containing task data.

The `accept` method accepts the task. The `Error` parameter indicates whether
there was an error.

The `reject` method rejects the task. The `Error` parameter indicates whether
there was an error.

The `done` method informs the orchestrator that a task is done. The
`Error` parameter indicates whether there was an error.

# GUARANTEES

1. It is safe to let the orchestrator client die, even with slow
   operations like `register_probe` or `update` pending.

2. Callbacks are always delayed, even in case of immediate errors.

# CAVEATS

1. The implementation will schedule any slow operation on a background thread
   used for I/O. As a consequence, depending on the thread from which you
   schedule slow operations, their final callbacks MAY be called from another
   thread context.

2. Slow operations operates on a copy of the internal state, so attribute
   changes performed after a slow operation is started will have no effect
   on such slow operations.

# EXAMPLE

See `example/ooni/oorchestrate.cpp`.

# HISTORY

The `orchestrate` module appeared in MeasurementKit 0.7.0.
