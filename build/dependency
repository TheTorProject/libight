#!/bin/sh

print_usage() {
    cat << EOF
usage: $0 dependency-name

Clones repository, configure, build and install dependency. By default sources
are below './build/third_party' and installed software is below './builtin/'.

Override default behavior by setting these environment variables:
  - pkg_clone_flags: extra flags for 'git clone' (e.g. '--recursive')
  - pkg_configure_flags: extra flags for './configure' (if any)
  - pkg_cmake_flags: extra flags for 'cmake .' (if CMakeLists.txt exists)
  - pkg_make_flags: extra flags for 'make' (e.g. 'V=0')
  - pkg_make_install_flags: extra flags for 'make install' (e.g. DESTDIR=/opt)
  - pkg_prefix: prefix where to install (e.g. '/usr/local')
  - pkg_steps: steps to execute (default is: 'depend configure make make_install')
  - pkg_sudo: optional comand to execute 'make install' with (e.g. sudo)

Examples:
  - download, patch, compile, and install libevent at /opt:
    - pkg_sudo=sudo pkg_prefix=/opt ./build/dependency libevent
  - use four processors to compile libressl:
    - pkg_make_flags=-j4 ./build/dependency libressl
EOF
}

pkg_chdir() {
    #
    # Note: we must have three layers of directory because old autotools
    # misbehave when we are using only two layers and specifically they try
    # to use measurement-kit's autotools rather than their own.
    #
    # See measurement-kit/measurement-kit#1017 build history for more.
    #
    cd ./build/third_party/$pkg_name
}

pkg_autogen() {
    if [ -x ./autogen.sh ]; then
        echo "- ./autogen.sh $pkg_autogen_sh_flags"
        ./autogen.sh $pkg_autogen_sh_flags
    elif [ -f ./configure.ac ]; then
        echo "- autoreconf -i"
        autoreconf -i
    fi
}

pkg_depend() {
    for dep in `echo $pkg_deps`; do
        if [ "$pkg_cross" != "" -a "$pkg_arch" != "" ]; then
            dep="$pkg_cross-$pkg_arch-$dep"
        fi
        if [ ! -f $pkg_rootdir/$dep.tgz ]; then
            baseurl=https://github.com/measurement-kit/dependencies
            wget -O $pkg_rootdir/$dep.tgz                                      \
                $baseurl/releases/download/2016-12-19/$dep.tgz
            wget -O $pkg_rootdir/$dep.tgz.asc                                  \
                $baseurl/releases/download/2016-12-19/$dep.tgz.asc
            gpg2 --verify $pkg_rootdir/$dep.tgz.asc
            install -d $pkg_prefix
            tar -C $pkg_prefix -xzf $pkg_rootdir/$dep.tgz
        else
            echo "It seems $dep has already been built and installed"
        fi
    done
}

pkg_configure() {
    if [ -x ./configure ]; then
        echo "- ./configure --prefix=$pkg_prefix $pkg_configure_flags"
        ./configure --prefix=/ $pkg_configure_flags
    elif [ -f ./CMakeLists.txt ]; then
        echo "- cmake -D CMAKE_INSTALL_PREFIX=$pkg_prefix $pkg_cmake_flags ."
        cmake -D CMAKE_INSTALL_PREFIX=/ $pkg_cmake_flags .
    fi
}

pkg_make() {
    echo "- make $pkg_make_flags"
    make $pkg_make_flags
}

pkg_make_install() {
    tmp_inst_dir="./xx"

    echo "- rm -rf $tmp_inst_dir"
    rm -rf $tmp_inst_dir

    echo "- make $pkg_make_install_flags install DESTDIR=$tmp_inst_dir"
    make $pkg_make_install_flags install DESTDIR=`pwd`/$tmp_inst_dir

    echo "- cleanup unnecessary files in $tmp_inst_dir/$pkg_prefix"
    (cd $tmp_inst_dir && find . -type f                                        \
       \( \! -name \*.h -and \! -name \*.hpp -and \! -name \*.a                \
                        -and \! -name \*.dylib -and \! -name \*.dylib.\*       \
                        -and \! -name \*.so -and \! -name \*.so.\* \)          \
         -exec rm {} \;)
    (cd $tmp_inst_dir && find . -depth -type d -empty -exec rmdir {} \;)

    echo "- install spec in $tmp_inst_dir/$pkg_prefix"
    install -d $tmp_inst_dir/spec
    install -m644 $pkg_rootdir/build/spec/$1 $tmp_inst_dir/spec/$1

    if [ "$pkg_cross" != "" -a "$pkg_arch" != "" ]; then
        pkg_archive="$pkg_cross-$pkg_arch-$pkg_archive"
    fi
    echo "- tar -cvzf $pkg_archive.tgz"
    (cd $tmp_inst_dir && tar -cvzf $pkg_rootdir/$pkg_archive.tgz .)

    echo "- $pkg_sudo tar -C $pkg_prefix $pkg_archive.tgz"
    install -d $pkg_prefix
    $pkg_sudo tar -C $pkg_prefix -xzf $pkg_rootdir/$pkg_archive.tgz
}

apply_patches() {
    if [ -d ../../../build/patch/$1 ]; then
        for diff in `find ../../../build/patch/$1 -type f`; do
            git apply -v $diff
        done
    fi
}

set -e
if [ $# -ne 1 ]; then
    print_usage
    exit 1
fi
pkg_rootdir=$(cd $(dirname $(dirname $0)) && pwd -P)
if [ -z "$pkg_prefix" ]; then
    pkg_prefix=$pkg_rootdir/builtin
fi
export pkg_prefix
cd $pkg_rootdir
# Note that the spec has access to $pkg_rootdir
. build/spec/$1
if [ "$pkg_repository" != "" ]; then
    rm -rf ./build/third_party/$pkg_name
    git clone $pkg_clone_flags --single-branch --depth 2                       \
        --branch $pkg_branch_or_tag $pkg_repository                            \
          ./build/third_party/$pkg_name
    cd ./build/third_party/$pkg_name
    if [ ! -z "$pkg_tip" ]; then
        if [ "`git rev-parse HEAD`" != "$pkg_tip" ]; then
            # Mainly because this allows us to know which commit was the
            # tip of the branch when we compiled a dependency
            echo "FATAL: unexpected HEAD commit SHA-1" 1>&2
            exit 1
        fi
    fi
    cd ../../../ # back to where we were
fi
pkg_chdir
apply_patches pre-autogen/$pkg_name/common
if [ "$pkg_cross" != "" ]; then
    apply_patches pre-autogen/$pkg_name/$pkg_cross
fi
pkg_autogen
apply_patches post-autogen/$pkg_name/common
if [ "$pkg_cross" != "" ]; then
    apply_patches post-autogen/$pkg_name/$pkg_cross
fi
if [ -z "$pkg_steps" ]; then
    pkg_steps="depend configure make make_install"
fi
for step in $pkg_steps; do
    echo ""
    echo "* step: $step $1"
    pkg_$step $1
done
echo ""
